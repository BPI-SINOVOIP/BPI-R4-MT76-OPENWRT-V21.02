/* File token_builder_core.c
   code generated by tbgen.py */

/*****************************************************************************
* Copyright (c) 2011-2022 by Rambus, Inc. and/or its subsidiaries.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 2 of the License, or
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
****************************************************************************/


/*----------------------------------------------------------------------------
 * This module implements (provides) the following interface(s):
 */

#include "token_builder.h"

/*----------------------------------------------------------------------------
 * This module uses (requires) the following interface(s):
 */

#include "c_token_builder.h"
#include "basic_defs.h"
#include "clib.h"
#include "token_builder_internal.h"
#include "token_builder_macros.h"

#include "log.h"

TokenBuilder_Status_t
TokenBuilder_GetSize(
    const void * const TokenContext_p,
    unsigned int * const TokenWord32Count_p
    )
{
    TokenBuilder_Context_t ContextCopy;
    TokenBuilder_Context_t *TokenContext_Internal_p = &ContextCopy;
    unsigned int WordCountOld = 0;


    uint32_t proto;
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t hproto;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t seq_offset;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t ivlen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t icvlen;
#endif
    uint32_t ivhandling;
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t extseq;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_SRTP == 1u || TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t antireplay;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t upd_handling;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t cipher_is_aes;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t hstatelen;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t capwap_out;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t is_nat;
#endif

#ifdef TKB_STRICT_ARGS_CHECK
    if (TokenWord32Count_p == NULL || TokenContext_p == NULL)
    {
        LOG_CRIT("TokenBuilder_GetSize: NULL pointer supplied\n");
        return TKB_INVALID_PARAMETER;
    }
#endif
    memcpy(TokenContext_Internal_p, TokenContext_p, sizeof(ContextCopy));

redo:
    *TokenWord32Count_p = TKB_TOKEN_HEADER_WORD_COUNT;

    *TokenWord32Count_p += 3u;
    ivhandling = EVAL_ivhandling();
    if (ivhandling >= 8u)
    {
        if (ivhandling < 10u)
        {
            *TokenWord32Count_p += 2u;
        }
        else if (ivhandling > 13u)
        {
            *TokenWord32Count_p += 4u;
        }
        else if (ivhandling == 10u)
        {
            *TokenWord32Count_p += 4u;
        }
        else if (ivhandling == 11u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 4u;
        }
    }
    *TokenWord32Count_p += 1u;
#if TKB_HAVE_PROTO_IPSEC == 1u
#if TKB_HAVE_EXTENDED_IPSEC == 1u
    hproto = EVAL_hproto();
    switch(hproto)
    {
    case 5: /* ipv4_out_transp */
        *TokenWord32Count_p += 2u;
        break;
    case 1: /* ipv4_out_transp_nohdrproc */
        *TokenWord32Count_p += 1u;
        break;
    case 11: /* ipv6_out_transp */
        *TokenWord32Count_p += 5u;
        break;
    case 2: /* ipv4_out_tunnel */
        *TokenWord32Count_p += 6u;
        break;
    case 7: /* ipv6_out_tunnel */
        *TokenWord32Count_p += 11u;
        break;
    case 6: /* ipv4_in_transp */
        *TokenWord32Count_p += 2u;
        break;
    case 3: /* ipv4_in_transp_nohdrproc */
        *TokenWord32Count_p += 1u;
        break;
    case 12: /* ipv6_in_transp */
        *TokenWord32Count_p += 5u;
        break;
    case 4: /* ipv4_in_tunnel */
    case 8: /* ipv6_in_tunnel */
    case 24: /* ipv4_in_tunnel_natt */
    case 28: /* ipv6_in_tunnel_natt */
        *TokenWord32Count_p += 2u;
        break;
    case 25: /* ipv4_out_transp_natt */
        *TokenWord32Count_p += 1u;
        is_nat = EVAL_is_nat();
        if (is_nat != 0u)
        {
            *TokenWord32Count_p += 4u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 3u;
        break;
    case 31: /* ipv6_out_transp_natt */
        *TokenWord32Count_p += 17u;
        break;
    case 22: /* ipv4_out_tunnel_natt */
        *TokenWord32Count_p += 8u;
        break;
    case 27: /* ipv6_out_tunnel_natt */
        *TokenWord32Count_p += 13u;
        break;
    case 26: /* ipv4_in_transp_natt */
        *TokenWord32Count_p += 1u;
        is_nat = EVAL_is_nat();
        if (is_nat != 0u)
        {
            *TokenWord32Count_p += 5u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 1u;
        break;
    case 32: /* ipv6_in_transp_natt */
        *TokenWord32Count_p += 15u;
        break;
    case 13: /* ipv4_out_dtls */
        *TokenWord32Count_p += 5u;
        break;
    case 33: /* ipv6_out_dtls */
        *TokenWord32Count_p += 5u;
        break;
    }
#endif
#endif
    proto = EVAL_proto();
    switch(proto)
    {
    case 0: /* esp_out */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (ivhandling == 2u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 1u;
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq == 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
#else
#endif
        break;
    case 1: /* esp_in */
#if TKB_HAVE_PROTO_IPSEC == 1u
#if TKB_HAVE_ECN_FIXUP == 1u
        *TokenWord32Count_p += 1u;
#endif
        if (ivhandling == 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq != 1u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
            }
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 2: /* esp_out_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        *TokenWord32Count_p += 5u;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 3u;
        }
        else
        {
            *TokenWord32Count_p += 5u;
        }
        *TokenWord32Count_p += 9u;
#else
#endif
        break;
    case 3: /* esp_in_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        *TokenWord32Count_p += 7u;
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            *TokenWord32Count_p += 3u;
        }
        else
        {
            *TokenWord32Count_p += 5u;
        }
        *TokenWord32Count_p += 1u;
#if TKB_HAVE_ECN_FIXUP == 1u
        *TokenWord32Count_p += 1u;
#endif
        *TokenWord32Count_p += 4u;
#else
#endif
        break;
    case 4: /* esp_out_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 3u;
        }
        *TokenWord32Count_p += 8u;
#else
#endif
        break;
    case 5: /* esp_in_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 4u;
        }
        *TokenWord32Count_p += 2u;
#if TKB_HAVE_ECN_FIXUP == 1u
        *TokenWord32Count_p += 1u;
#endif
        *TokenWord32Count_p += 3u;
#else
#endif
        break;
    case 6: /* esp_out_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 3u;
        }
        *TokenWord32Count_p += 8u;
#else
#endif
        break;
    case 7: /* esp_in_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 4u;
        }
        *TokenWord32Count_p += 2u;
#if TKB_HAVE_ECN_FIXUP == 1u
        *TokenWord32Count_p += 1u;
#endif
        *TokenWord32Count_p += 3u;
#else
#endif
        break;
    case 8: /* ssltls_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        capwap_out = EVAL_capwap_out();
        if (capwap_out != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 3u;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 6u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            *TokenWord32Count_p += 3u;
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 4u;
            break;
        case 2: /* upd_iv2 */
            *TokenWord32Count_p += 1u;
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 2u;
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 2u;
            break;
        case 4: /* upd_blk */
            *TokenWord32Count_p += 4u;
            break;
        }
#else
#endif
        break;
    case 9: /* ssltls_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        upd_handling = EVAL_upd_handling();
        if (upd_handling <= 1u)
        {
            *TokenWord32Count_p += 3u;
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                *TokenWord32Count_p += 7u;
            }
            else
            {
                *TokenWord32Count_p += 2u;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 2u;
                }
                *TokenWord32Count_p += 2u;
            }
            *TokenWord32Count_p += 3u;
            switch(upd_handling)
            {
            case 0: /* upd_null */
                *TokenWord32Count_p += 1u;
                if (extseq == 0u)
                {
                    *TokenWord32Count_p += 2u;
                }
                else if (extseq == 1u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 2u;
                }
                break;
            case 1: /* upd_arc4 */
                *TokenWord32Count_p += 5u;
                break;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
            cipher_is_aes = EVAL_cipher_is_aes();
            if (cipher_is_aes == 0u)
            {
                *TokenWord32Count_p += 6u;
            }
            else
            {
                *TokenWord32Count_p += 10u;
            }
            *TokenWord32Count_p += 3u;
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                *TokenWord32Count_p += 6u;
            }
            else
            {
                *TokenWord32Count_p += 3u;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 1u;
            ivlen = EVAL_ivlen();
            if (ivlen > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 3u;
            switch(upd_handling)
            {
            case 2: /* upd_iv2 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
                *TokenWord32Count_p += 2u;
                break;
            case 3: /* upd_iv4 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
                *TokenWord32Count_p += 2u;
                break;
            case 4: /* upd_blk */
                if (extseq == 0u)
                {
                    *TokenWord32Count_p += 2u;
                }
                else if (extseq == 1u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 2u;
                }
                break;
            }
        }
#else
#endif
        break;
    case 21: /* ssltls_gcm_out */
    case 37: /* ssltls_chachapoly_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        capwap_out = EVAL_capwap_out();
        if (capwap_out != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 4u;
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 5u;
        if (proto != 37u)
        {
            if (extseq != 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 4u;
#else
#endif
        break;
    case 22: /* ssltls_gcm_in */
    case 38: /* ssltls_chachapoly_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        *TokenWord32Count_p += 11u;
        if (proto != 38u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
#if TKB_HAVE_CHACHAPOLY_HW30 == 1u
            *TokenWord32Count_p += 1u;
#else
            *TokenWord32Count_p += 1u;
#endif
        }
        *TokenWord32Count_p += 2u;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else if (extseq == 1u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 10: /* basic_crypto */
#if TKB_HAVE_PROTO_BASIC == 1u
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 1: /* iv_inbound_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 2u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 2u;
            break;
        case 2: /* upd_iv2 */
            *TokenWord32Count_p += 1u;
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            break;
        }
#else
#endif
        break;
    case 11: /* basic_hash */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 1u;
            hstatelen = EVAL_hstatelen();
            if (hstatelen > 16u)
            {
                *TokenWord32Count_p += 1u;
            }
        }
#else
#endif
        break;
    case 14: /* basic_crypthash */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 1: /* iv_inbound_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 1u;
            break;
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 4u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 1u;
            hstatelen = EVAL_hstatelen();
            if (hstatelen > 16u)
            {
                *TokenWord32Count_p += 1u;
            }
        }
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            *TokenWord32Count_p += 2u;
            break;
        case 2: /* upd_iv2 */
            *TokenWord32Count_p += 1u;
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            break;
        }
#else
#endif
        break;
    case 15: /* basic_out_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 2u;
        if (ivhandling == 5u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 25u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 16: /* basic_in_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 2u;
        if (ivhandling == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 25u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 17: /* basic_out_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 2u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 2u;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 2u;
            break;
        default:
            *TokenWord32Count_p += 1u;
            ;
        }
        *TokenWord32Count_p += 2u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 18: /* basic_in_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 2u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 2u;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 2u;
            break;
        default:
            *TokenWord32Count_p += 1u;
            ;
        }
        *TokenWord32Count_p += 2u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 19: /* basic_out_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 3u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 3u;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 3u;
            break;
        default:
            *TokenWord32Count_p += 2u;
            ;
        }
        *TokenWord32Count_p += 1u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
#else
#endif
        break;
    case 20: /* basic_in_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            *TokenWord32Count_p += 3u;
            break;
        case 5: /* iv_copy_ctr */
            *TokenWord32Count_p += 3u;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            *TokenWord32Count_p += 3u;
            break;
        default:
            *TokenWord32Count_p += 2u;
            ;
        }
        *TokenWord32Count_p += 1u;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 23: /* basic_xts_crypto */
#if TKB_HAVE_CRYPTO_XTS == 1u
        *TokenWord32Count_p += 5u;
        switch(ivhandling)
        {
        case 1: /* iv_inbound_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 2u;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 3: /* upd_iv4 */
            *TokenWord32Count_p += 1u;
            break;
        }
#else
#endif
        break;
    case 24: /* basic_kasumi_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        *TokenWord32Count_p += 3u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
#else
#endif
        break;
    case 25: /* basic_snow_hash */
    case 26: /* basic_zuc_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        *TokenWord32Count_p += 5u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 2u;
#else
#endif
        break;
    case 27: /* basic_hashenc */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 17u;
        switch(ivhandling)
        {
        case 4: /* iv_copy_cbc */
            *TokenWord32Count_p += 1u;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            *TokenWord32Count_p += 1u;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            *TokenWord32Count_p += 1u;
            break;
        }
        *TokenWord32Count_p += 3u;
#else
#endif
        break;
    case 28: /* basic_dechash */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 1u;
        cipher_is_aes = EVAL_cipher_is_aes();
        if (cipher_is_aes == 0u)
        {
            *TokenWord32Count_p += 6u;
        }
        else
        {
            *TokenWord32Count_p += 10u;
        }
        *TokenWord32Count_p += 21u;
        ivlen = EVAL_ivlen();
        if (ivlen > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 4u;
#else
#endif
        break;
    case 12: /* srtp_out */
#if TKB_HAVE_PROTO_SRTP == 1u
        *TokenWord32Count_p += 2u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 1u;
        antireplay = EVAL_antireplay();
        if (antireplay > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 1u;
#else
#endif
        break;
    case 13: /* srtp_in */
#if TKB_HAVE_PROTO_SRTP == 1u
        *TokenWord32Count_p += 2u;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
        antireplay = EVAL_antireplay();
        if (antireplay > 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            *TokenWord32Count_p += 1u;
            if (antireplay > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
            if (antireplay > 0u)
            {
                *TokenWord32Count_p += 1u;
            }
        }
#else
#endif
        break;
    case 29: /* basic_out_chachapoly */
#if TKB_HAVE_PROTO_BASIC == 1u
#if TKB_HAVE_CRYPTO_CHACHAPOLY == 1u
        *TokenWord32Count_p += 19u;
#else
#endif
#else
#endif
        break;
    case 30: /* basic_in_chachapoly */
#if TKB_HAVE_PROTO_BASIC == 1u
#if TKB_HAVE_CRYPTO_CHACHAPOLY == 1u
        *TokenWord32Count_p += 17u;
#if TKB_HAVE_CHACHAPOLY_HW30 == 1u
        *TokenWord32Count_p += 1u;
#else
        *TokenWord32Count_p += 1u;
#endif
        *TokenWord32Count_p += 3u;
#else
#endif
#else
#endif
        break;
    case 31: /* tls13_gcm_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        *TokenWord32Count_p += 12u;
#else
#endif
        break;
    case 32: /* tls13_gcm_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        *TokenWord32Count_p += 7u;
#else
#endif
        break;
    case 33: /* tls13_chachapoly_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        *TokenWord32Count_p += 10u;
#else
#endif
        break;
    case 34: /* tls13_chachapoly_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        *TokenWord32Count_p += 6u;
#else
#endif
        break;
    case 35: /* esp_out_chachapoly */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 3u;
        }
        *TokenWord32Count_p += 6u;
#else
#endif
        break;
    case 36: /* esp_in_chachapoly */
#if TKB_HAVE_PROTO_IPSEC == 1u
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            *TokenWord32Count_p += 2u;
#if TKB_HAVE_ECN_FIXUP == 1u
            *TokenWord32Count_p += 1u;
#endif
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 5u;
#if TKB_HAVE_ECN_FIXUP == 1u
            *TokenWord32Count_p += 1u;
#endif
#if TKB_HAVE_CHACHAPOLY_HW30 == 1u
            *TokenWord32Count_p += 1u;
#else
            *TokenWord32Count_p += 1u;
#endif
        }
        *TokenWord32Count_p += 2u;
#else
#endif
        break;
    case 39: /* ssltls_ccm_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        *TokenWord32Count_p += 1u;
        capwap_out = EVAL_capwap_out();
        if (capwap_out != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 11u;
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        *TokenWord32Count_p += 6u;
        if (extseq != 0u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        *TokenWord32Count_p += 6u;
#else
#endif
        break;
    case 40: /* ssltls_ccm_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        *TokenWord32Count_p += 24u;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            *TokenWord32Count_p += 2u;
        }
        else if (extseq == 1u)
        {
            *TokenWord32Count_p += 1u;
        }
        else
        {
            *TokenWord32Count_p += 2u;
        }
#else
#endif
        break;
    case 41: /* tls13_ccm_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        *TokenWord32Count_p += 19u;
#else
#endif
        break;
    case 42: /* tls13_ccm_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        *TokenWord32Count_p += 14u;
#else
#endif
        break;
    case 43: /* basic_hmac_precompute */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 4u;
#else
#endif
        break;
    case 44: /* basic_hmac_ctxprepare */
#if TKB_HAVE_PROTO_BASIC == 1u
        *TokenWord32Count_p += 6u;
#else
#endif
        break;
    case 45: /* basic_bypass */
        *TokenWord32Count_p += 1u;
        break;
    default:
        ;
    }
#if TKB_HAVE_PROTO_IPSEC == 1u
#if TKB_HAVE_EXTENDED_IPSEC == 1u
    hproto = EVAL_hproto();
    switch(hproto)
    {
    case 6: /* ipv4_in_transp */
    case 26: /* ipv4_in_transp_natt */
        *TokenWord32Count_p += 1u;
        break;
    case 12: /* ipv6_in_transp */
    case 32: /* ipv6_in_transp_natt */
        *TokenWord32Count_p += 2u;
        break;
    }
#endif
    switch(proto)
    {
    case 1: /* esp_in */
    case 3: /* esp_in_ccm */
    case 5: /* esp_in_gcm */
    case 7: /* esp_in_gmac */
    case 36: /* esp_in_chachapoly */
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            antireplay = EVAL_antireplay();
            if (antireplay > 12u)
            {
                *TokenWord32Count_p += 1u;
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
            }
            else if (antireplay != 0u)
            {
                *TokenWord32Count_p += 1u;
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    *TokenWord32Count_p += 1u;
                }
                else
                {
                    *TokenWord32Count_p += 1u;
                }
            }
            else
            {
                *TokenWord32Count_p += 1u;
            }
        }
        else
        {
            *TokenWord32Count_p += 1u;
        }
        break;
    }
#endif


    if (Switch_Proto(TokenContext_Internal_p))
    {
        /* Protocol was switched (HMAC context prepare to original protocol),
           redo size computation with original protocol.*/
        WordCountOld = *TokenWord32Count_p;
        goto redo;
    }
    *TokenWord32Count_p = MAX(*TokenWord32Count_p, WordCountOld);

   return TKB_STATUS_OK;
}


TokenBuilder_Status_t
TokenBuilder_BuildToken(
    void * const TokenContext_p,
    const uint8_t *const Packet_p,
    const uint32_t PacketByteCount,
    TokenBuilder_Params_t * const TKBParams_p,
    void * const Token_p,
    uint32_t * const TokenWord32Count_p,
    uint32_t * const TokenHeaderWord_p)
{
    uint32_t *tp = (uint32_t*)Token_p;
    uint32_t rc = TKB_STATUS_OK;
    TokenBuilder_Context_t *TokenContext_Internal_p =
        (TokenBuilder_Context_t*)TokenContext_p;
    uint32_t proto;
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t hproto;
#endif
    uint32_t packetsize;
    uint32_t bypass;
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t nextheader;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t pad_remainder;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t pad_blocksize;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t pad_bytes;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t seq_offset;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t iv_offset;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t digest_offset;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t ivlen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t icvlen;
#endif
    uint32_t ivhandling;
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u
    uint32_t extseq;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t salt;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t basic_salt;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t paylen;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t swaplen;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t swap_fraglen;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t swap_fraglen_tls13;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t swaplen3;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t swaplen3_tls13_out;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t swaplen3_tls13_in;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t hashpad_tls13_out;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t hashpad_tls13_in;
#endif
#if TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t hashpad;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_pkt;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_tkn;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_out;
#endif
#if TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t swap_j;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t basic_swaplen;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadlen_swap;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t aadpad;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t basic_hashpad;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u || TKB_HAVE_PROTO_SRTP == 1u || TKB_HAVE_PROTO_IPSEC == 1u
    uint32_t antireplay;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t upd_handling;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    uint32_t cipher_is_aes;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_WIRELESS == 1u
    uint32_t appendhash;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u || TKB_HAVE_CRYPTO_XTS == 1u
    uint32_t pad_bytes_basic;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t hstatelen;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t capwap_out;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t capwap_in;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t hstatelen_bytes;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    uint32_t pad_bytes_hashenc;
#endif
#if TKB_HAVE_PROTO_SRTP == 1u
    uint32_t srtp_offset;
#endif
#if TKB_HAVE_PROTO_SRTP == 1u
    uint32_t srtp_swaproc;
#endif
    uint32_t srtp_iv0;
    uint32_t srtp_iv1;
    uint32_t srtp_iv2;
    uint32_t srtp_iv3;
    uint32_t count;
    uint32_t bearer_dir_fresh;
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t prev_nhoffset;
#endif
    uint32_t hdrlen;
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u) || TKB_HAVE_PROTO_IPSEC == 1u || TKB_HAVE_PROTO_SSLTLS == 1u
    uint32_t ohdrlen;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t outlen;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t nh;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t is_nat;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t tunnel_w0_ip4;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t tunnel_w1_ip4;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t tunnel_w2_ip4;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t tunnel_w0_ip6;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t tunnel_w1_ip6;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    const uint8_t *tunnel_ip_addr;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    const uint8_t *dst_ip_addr;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_EXTENDED_IPSEC == 1u)
    uint32_t ports_natt;
#endif
#if (TKB_HAVE_PROTO_IPSEC == 1u && TKB_HAVE_ECN_FIXUP == 1u)
    uint32_t ecn_fixup_instr;
#endif
    uint32_t per_packet_options;
    uint32_t u_word;
    uint32_t cw0;
    uint32_t cw1;
    const uint8_t *iv;
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    const uint8_t *ssltls_lastblock;
#endif
#if TKB_HAVE_PROTO_SSLTLS == 1u || TKB_HAVE_PROTO_BASIC == 1u
    const uint8_t *ssltls_lastword;
#endif
#if TKB_HAVE_PROTO_BASIC == 1u
    const uint8_t *aad;
#endif

    IDENTIFIER_NOT_USED(Packet_p);
#ifdef TKB_STRICT_ARGS_CHECK
    if (Token_p == NULL ||
        TokenWord32Count_p == NULL ||
        (TokenHeaderWord_p == NULL && TKB_TOKEN_HEADER_WORD_COUNT == 0))
    {
        LOG_CRIT("TokenBuilder: NULL pointer supplied\n");
        return TKB_INVALID_PARAMETER;
    }
#endif
    if (TokenContext_p == NULL)
    {
        rc = TKB_ERROR;
        TKBParams_p->CLE = 2;
        goto error;
    }

    if (TokenHeaderWord_p != NULL)
        *TokenHeaderWord_p = EVAL_TokenHeaderWord();
#if TKB_TOKEN_HEADER_WORD_COUNT > 0
    {
        unsigned int i;
        *tp++ = EVAL_TokenHeaderWord();
        for (i = 0; i < TKB_TOKEN_HEADER_WORD_COUNT - 1; i++)
        {
            *tp++ = 0;
        }
    }
#endif

    per_packet_options = EVAL_per_packet_options();
    if (per_packet_options != 0u)
    {
        /* DATA32 cw0 + per_packet_options */
        cw0 = EVAL_cw0();
        *tp++=0x00000000 | ((cw0+per_packet_options)&0xffffffffu)<<0;
        /* DATA32 cw1 */
        cw1 = EVAL_cw1();
        *tp++=0x00000000 | ((cw1)&0xffffffffu)<<0;
    }
    bypass = EVAL_bypass();
    hdrlen = EVAL_hdrlen();
    if (hdrlen == 4294967295u)
    {
        LOG_WARN("TokenBuilder: bad packet, ip header parse error\n");
        rc = TKB_BAD_PACKET; goto error;
    }
    proto = EVAL_proto();
    u_word = EVAL_u_word();
    if (u_word != 0u)
    {
        /* DATA32 u_word */
        *tp++=0x00000000 | ((u_word)&0xffffffffu)<<0;
    }
    ivhandling = EVAL_ivhandling();
    if (ivhandling >= 8u)
    {
        if (ivhandling < 10u)
        {
            iv = EVAL_iv();
            TokenBuilder_CopyBytes(tp, iv, 8);
            tp += 2;
        }
        else if (ivhandling > 13u)
        {
            iv = EVAL_iv();
            TokenBuilder_CopyBytes(tp, iv, 16);
            tp += 4;
        }
        else if (ivhandling == 10u)
        {
            /* DATA32 srtp_iv0 */
            srtp_iv0 = EVAL_srtp_iv0();
            *tp++=0x00000000 | ((srtp_iv0)&0xffffffffu)<<0;
            /* DATA32 srtp_iv1 */
            srtp_iv1 = EVAL_srtp_iv1();
            *tp++=0x00000000 | ((srtp_iv1)&0xffffffffu)<<0;
            /* DATA32 srtp_iv2 */
            srtp_iv2 = EVAL_srtp_iv2();
            *tp++=0x00000000 | ((srtp_iv2)&0xffffffffu)<<0;
            /* DATA32 srtp_iv3 */
            srtp_iv3 = EVAL_srtp_iv3();
            *tp++=0x00000000 | ((srtp_iv3)&0xffffffffu)<<0;
        }
        else if (ivhandling == 11u)
        {
            /* DATA32 count */
            count = EVAL_count();
            *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
            /* DATA32 bearer_dir_fresh */
            bearer_dir_fresh = EVAL_bearer_dir_fresh();
            *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        }
        else
        {
            /* DATA32 count */
            count = EVAL_count();
            *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
            /* DATA32 bearer_dir_fresh */
            bearer_dir_fresh = EVAL_bearer_dir_fresh();
            *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
            /* DATA32 count */
            *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
            /* DATA32 bearer_dir_fresh */
            *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        }
    }
    if (bypass > 0u)
    {
        if (proto != 9u)
        {
            if (proto != 28u)
            {
                /* DIR OUT,bypass */
                *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
            }
        }
    }
    packetsize = EVAL_packetsize();
    if (packetsize > 131071u)
    {
        LOG_WARN("TokenBuilder: bad packet, too long\n");
        rc = TKB_BAD_PACKET; goto error;
    }
#if TKB_HAVE_PROTO_IPSEC == 1u
#if TKB_HAVE_EXTENDED_IPSEC == 1u
    hproto = EVAL_hproto();
    switch(hproto)
    {
    case 5: /* ipv4_out_transp */
        /* IPV4CHK OUT,50,outlen */
        outlen = EVAL_outlen();
        *tp++=0x61000000 | ((50u)&0xffu)<<16 | ((outlen)&0xffffu)<<0;
        /* DIR OUT,hdrlen-12 */
        *tp++=0x01000000 | ((-12u+hdrlen)&0x1ffffu)<<0;
        break;
    case 1: /* ipv4_out_transp_nohdrproc */
        /* DIR OUT,hdrlen */
        *tp++=0x01000000 | ((hdrlen)&0x1ffffu)<<0;
        break;
    case 11: /* ipv6_out_transp */
        if (hdrlen > 40u)
        {
            /* IPV6 OUT,nh,outlen-40 */
            nh = EVAL_nh();
            outlen = EVAL_outlen();
            *tp++=0x81000000 | ((nh)&0xffu)<<16 | ((-40u+outlen)&0xffffu)<<0;
            /* DIR OUT,prev_nhoffset-8    ; -8 to include two 32-bit words of the IPv6 header passed via IPV6 instruction */
            prev_nhoffset = EVAL_prev_nhoffset();
            *tp++=0x01000000 | ((-8u+prev_nhoffset)&0x1ffffu)<<0;
            /* REPL OUT,ORIG_TOKEN,1                ; replace NH byte of the last extension header with ESP type */
            *tp++=0x31d80000 | ((1u)&0x1ffffu)<<0;
            /* DATA32 50                            ; ESP proto */
            *tp++=0x00000000 | ((50u)&0xffffffffu)<<0;
            /* DIR OUT,hdrlen-prev_nhoffset-1    ; bypass the rest of the last extension header */
            *tp++=0x01000000 | ((-1u+hdrlen-prev_nhoffset)&0x1ffffu)<<0;
        }
        else
        {
            /* IPV6 OUT,50,outlen-hdrlen */
            outlen = EVAL_outlen();
            *tp++=0x81000000 | ((50u)&0xffu)<<16 | ((outlen-hdrlen)&0xffffu)<<0;
            /* DIR OUT,hdrlen-8 */
            *tp++=0x01000000 | ((-8u+hdrlen)&0x1ffffu)<<0;
        }
        break;
    case 2: /* ipv4_out_tunnel */
        /* INS OUT,ORIG_TOKEN,20 */
        *tp++=0x21d80000 | ((20u)&0x1ffffu)<<0;
        /* DATA32 tunnel_w0_ip4 */
        tunnel_w0_ip4 = EVAL_tunnel_w0_ip4();
        *tp++=0x00000000 | ((tunnel_w0_ip4)&0xffffffffu)<<0;
        /* DATA32 tunnel_w1_ip4 */
        tunnel_w1_ip4 = EVAL_tunnel_w1_ip4();
        *tp++=0x00000000 | ((tunnel_w1_ip4)&0xffffffffu)<<0;
        /* DATA32 tunnel_w2_ip4 */
        tunnel_w2_ip4 = EVAL_tunnel_w2_ip4();
        *tp++=0x00000000 | ((tunnel_w2_ip4)&0xffffffffu)<<0;
        tunnel_ip_addr = EVAL_tunnel_ip_addr();
        TokenBuilder_CopyBytes(tp, tunnel_ip_addr, 8);
        tp += 2;
        break;
    case 7: /* ipv6_out_tunnel */
        /* INS OUT,ORIG_TOKEN,40 */
        *tp++=0x21d80000 | ((40u)&0x1ffffu)<<0;
        /* DATA32 tunnel_w0_ip6 */
        tunnel_w0_ip6 = EVAL_tunnel_w0_ip6();
        *tp++=0x00000000 | ((tunnel_w0_ip6)&0xffffffffu)<<0;
        /* DATA32 tunnel_w1_ip6 */
        tunnel_w1_ip6 = EVAL_tunnel_w1_ip6();
        *tp++=0x00000000 | ((tunnel_w1_ip6)&0xffffffffu)<<0;
        tunnel_ip_addr = EVAL_tunnel_ip_addr();
        TokenBuilder_CopyBytes(tp, tunnel_ip_addr, 32);
        tp += 8;
        break;
    case 6: /* ipv4_in_transp */
        /* IPV4CHK OUT,0,0 */
        *tp++=0x61000000 | ((0u)&0xffu)<<16 | ((0u)&0xffffu)<<0;
        /* DIR OUT,hdrlen-12 */
        *tp++=0x01000000 | ((-12u+hdrlen)&0x1ffffu)<<0;
        break;
    case 3: /* ipv4_in_transp_nohdrproc */
        /* DIR OUT, hdrlen */
        *tp++=0x01000000 | ((hdrlen)&0x1ffffu)<<0;
        break;
    case 12: /* ipv6_in_transp */
        nh = EVAL_nh();
        if (nh == 50u)
        {
            /* IPV6 OUT,00,00                      ; zeroise the NH and payload length */
            *tp++=0x81000000 | ((0u)&0xffu)<<16 | ((0u)&0xffffu)<<0;
            /* DIR OUT,hdrlen-8                    ; pass the remaining header words */
            *tp++=0x01000000 | ((-8u+hdrlen)&0x1ffffu)<<0;
        }
        else
        {
            /* IPV6 OUT,nh,00                      ; bypass NH, but zeroise the payload length */
            *tp++=0x81000000 | ((nh)&0xffu)<<16 | ((0u)&0xffffu)<<0;
            /* DIR OUT,prev_nhoffset-8   ; pass the remaining data until the next header of the last extentnio header */
            prev_nhoffset = EVAL_prev_nhoffset();
            *tp++=0x01000000 | ((-8u+prev_nhoffset)&0x1ffffu)<<0;
            /* REPL OUT,ORIG_TOKEN,1               ; zeroize the NH field */
            *tp++=0x31d80000 | ((1u)&0x1ffffu)<<0;
            /* DATA32 00                           ; */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DIR OUT,hdrlen-prev_nhoffset-1      ; bypass the rest of the last extension header */
            *tp++=0x01000000 | ((-1u+hdrlen-prev_nhoffset)&0x1ffffu)<<0;
        }
        break;
    case 4: /* ipv4_in_tunnel */
    case 8: /* ipv6_in_tunnel */
    case 24: /* ipv4_in_tunnel_natt */
    case 28: /* ipv6_in_tunnel_natt */
        /* DIR OUT, ohdrlen     ; keep (optionally) outer IP heade */
        ohdrlen = EVAL_ohdrlen();
        *tp++=0x01000000 | ((ohdrlen)&0x1ffffu)<<0;
        /* REM hdrlen-ohdrlen   ; remobe IP header (optionally) and NATT header. */
        *tp++=0x40d80000 | ((hdrlen-ohdrlen)&0x1ffffu)<<0;
        break;
    case 25: /* ipv4_out_transp_natt */
        /* IPV4CHK OUT,17,outlen    ; include 8 byte of NAT-T */
        outlen = EVAL_outlen();
        *tp++=0x61000000 | ((17u)&0xffu)<<16 | ((outlen)&0xffffu)<<0;
        is_nat = EVAL_is_nat();
        if (is_nat != 0u)
        {
            /* REPL OUT,ORIG_TOKEN,8 */
            *tp++=0x31d80000 | ((8u)&0x1ffffu)<<0;
            tunnel_ip_addr = EVAL_tunnel_ip_addr();
            TokenBuilder_CopyBytes(tp, tunnel_ip_addr, 8);
            tp += 2;
            /* DIR OUT,hdrlen-20 */
            *tp++=0x01000000 | ((-20u+hdrlen)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR OUT,hdrlen-12 */
            *tp++=0x01000000 | ((-12u+hdrlen)&0x1ffffu)<<0;
        }
        /* INS OUT,ORIG_TOKEN,8 */
        *tp++=0x21d80000 | ((8u)&0x1ffffu)<<0;
        /* DATA32 ports_natt */
        ports_natt = EVAL_ports_natt();
        *tp++=0x00000000 | ((ports_natt)&0xffffffffu)<<0;
        /* SWAP16 outlen - hdrlen ; include 8 byte of NAT-T */
        *tp++ = ByteSwap16(outlen-hdrlen);
        break;
    case 31: /* ipv6_out_transp_natt */
        if (hdrlen > 40u)
        {
            /* IPV6 OUT,nh,outlen-40              ; include 8 bytes of NAT-T */
            nh = EVAL_nh();
            outlen = EVAL_outlen();
            *tp++=0x81000000 | ((nh)&0xffu)<<16 | ((-40u+outlen)&0xffffu)<<0;
            is_nat = EVAL_is_nat();
            if (is_nat != 0u)
            {
                /* REPL OUT,ORIG_TOKEN,32 */
                *tp++=0x31d80000 | ((32u)&0x1ffffu)<<0;
                tunnel_ip_addr = EVAL_tunnel_ip_addr();
                TokenBuilder_CopyBytes(tp, tunnel_ip_addr, 32);
                tp += 8;
                /* DIR OUT,prev_nhoffset-40 */
                prev_nhoffset = EVAL_prev_nhoffset();
                *tp++=0x01000000 | ((-40u+prev_nhoffset)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR OUT,prev_nhoffset-8    ; -8 to include two 32-bit words of the IPv6 header passed via IPV6 instruction */
                prev_nhoffset = EVAL_prev_nhoffset();
                *tp++=0x01000000 | ((-8u+prev_nhoffset)&0x1ffffu)<<0;
            }
            /* REPL OUT,ORIG_TOKEN,1                ; replace NH byte of the last extension header with UDP type */
            *tp++=0x31d80000 | ((1u)&0x1ffffu)<<0;
            /* DATA32 17                            ; */
            *tp++=0x00000000 | ((17u)&0xffffffffu)<<0;
            /* DIR OUT,hdrlen-prev_nhoffset-1    ; bypass the rest data of the last extension header */
            prev_nhoffset = EVAL_prev_nhoffset();
            *tp++=0x01000000 | ((-1u+hdrlen-prev_nhoffset)&0x1ffffu)<<0;
        }
        else
        {
            /* IPV6 OUT,17,outlen-hdrlen         ; include 8 bytes of NAT-T */
            outlen = EVAL_outlen();
            *tp++=0x81000000 | ((17u)&0xffu)<<16 | ((outlen-hdrlen)&0xffffu)<<0;
            is_nat = EVAL_is_nat();
            if (is_nat != 0u)
            {
                /* REPL OUT,ORIG_TOKEN,32 */
                *tp++=0x31d80000 | ((32u)&0x1ffffu)<<0;
                tunnel_ip_addr = EVAL_tunnel_ip_addr();
                TokenBuilder_CopyBytes(tp, tunnel_ip_addr, 32);
                tp += 8;
                /* DIR OUT,hdrlen-40 */
                *tp++=0x01000000 | ((-40u+hdrlen)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR OUT,hdrlen-8 */
                *tp++=0x01000000 | ((-8u+hdrlen)&0x1ffffu)<<0;
            }
        }
        /* INS OUT,ORIG_TOKEN,8 */
        *tp++=0x21d80000 | ((8u)&0x1ffffu)<<0;
        /* DATA32 ports_natt */
        ports_natt = EVAL_ports_natt();
        *tp++=0x00000000 | ((ports_natt)&0xffffffffu)<<0;
        outlen = EVAL_outlen();
        /* SWAP16 outlen-hdrlen                  ; include 8 bytes of NAT-T */
        *tp++ = ByteSwap16(outlen-hdrlen);
        break;
    case 22: /* ipv4_out_tunnel_natt */
        /* INS OUT,ORIG_TOKEN,28 */
        *tp++=0x21d80000 | ((28u)&0x1ffffu)<<0;
        /* DATA32 tunnel_w0_ip4 */
        tunnel_w0_ip4 = EVAL_tunnel_w0_ip4();
        *tp++=0x00000000 | ((tunnel_w0_ip4)&0xffffffffu)<<0;
        /* DATA32 tunnel_w1_ip4 */
        tunnel_w1_ip4 = EVAL_tunnel_w1_ip4();
        *tp++=0x00000000 | ((tunnel_w1_ip4)&0xffffffffu)<<0;
        /* DATA32 tunnel_w2_ip4 */
        tunnel_w2_ip4 = EVAL_tunnel_w2_ip4();
        *tp++=0x00000000 | ((tunnel_w2_ip4)&0xffffffffu)<<0;
        tunnel_ip_addr = EVAL_tunnel_ip_addr();
        TokenBuilder_CopyBytes(tp, tunnel_ip_addr, 8);
        tp += 2;
        /* DATA32 ports_natt */
        ports_natt = EVAL_ports_natt();
        *tp++=0x00000000 | ((ports_natt)&0xffffffffu)<<0;
        outlen = EVAL_outlen();
        ohdrlen = EVAL_ohdrlen();
        /* SWAP16 outlen+8 - ohdrlen                ; include 8 byte of NAT-T */
        *tp++ = ByteSwap16(8u+outlen-ohdrlen);
        break;
    case 27: /* ipv6_out_tunnel_natt */
        /* INS OUT,ORIG_TOKEN,48 */
        *tp++=0x21d80000 | ((48u)&0x1ffffu)<<0;
        /* DATA32 tunnel_w0_ip6 */
        tunnel_w0_ip6 = EVAL_tunnel_w0_ip6();
        *tp++=0x00000000 | ((tunnel_w0_ip6)&0xffffffffu)<<0;
        /* DATA32 tunnel_w1_ip6 */
        tunnel_w1_ip6 = EVAL_tunnel_w1_ip6();
        *tp++=0x00000000 | ((tunnel_w1_ip6)&0xffffffffu)<<0;
        tunnel_ip_addr = EVAL_tunnel_ip_addr();
        TokenBuilder_CopyBytes(tp, tunnel_ip_addr, 32);
        tp += 8;
        /* DATA32 ports_natt */
        ports_natt = EVAL_ports_natt();
        *tp++=0x00000000 | ((ports_natt)&0xffffffffu)<<0;
        outlen = EVAL_outlen();
        ohdrlen = EVAL_ohdrlen();
        /* SWAP16 outlen+8 - ohdrlen                ; include 8 byte of NAT-T */
        *tp++ = ByteSwap16(8u+outlen-ohdrlen);
        break;
    case 26: /* ipv4_in_transp_natt */
        /* IPV4CHK OUT,0,0                         ; IP header update instruction */
        *tp++=0x61000000 | ((0u)&0xffu)<<16 | ((0u)&0xffffu)<<0;
        is_nat = EVAL_is_nat();
        if (is_nat != 0u)
        {
            /* REPL OUT,ORIG_TOKEN,4 */
            *tp++=0x31d80000 | ((4u)&0x1ffffu)<<0;
            tunnel_ip_addr = EVAL_tunnel_ip_addr();
            TokenBuilder_CopyBytes(tp, tunnel_ip_addr, 4);
            tp += 1;
            /* REPL OUT,ORIG_TOKEN,4 */
            *tp++=0x31d80000 | ((4u)&0x1ffffu)<<0;
            dst_ip_addr = EVAL_dst_ip_addr();
            TokenBuilder_CopyBytes(tp, dst_ip_addr, 4);
            tp += 1;
            /* DIR OUT,hdrlen-20-8 */
            *tp++=0x01000000 | ((-28u+hdrlen)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR OUT,hdrlen-12-8                     ; bypass the rest of IP header words */
            *tp++=0x01000000 | ((-20u+hdrlen)&0x1ffffu)<<0;
        }
        /* REM 8                                   ; remove NAT-T UDP header */
        *tp++=0x40d80000 | ((8u)&0x1ffffu)<<0;
        break;
    case 32: /* ipv6_in_transp_natt */
        nh = EVAL_nh();
        if (nh == 17u)
        {
            /* IPV6 OUT,00,00                      ; bypass IPv6 header and zeroise length and protocol fields */
            *tp++=0x81000000 | ((0u)&0xffu)<<16 | ((0u)&0xffffu)<<0;
            is_nat = EVAL_is_nat();
            if (is_nat != 0u)
            {
                /* REPL OUT,ORIG_TOKEN,32 */
                *tp++=0x31d80000 | ((32u)&0x1ffffu)<<0;
                tunnel_ip_addr = EVAL_tunnel_ip_addr();
                TokenBuilder_CopyBytes(tp, tunnel_ip_addr, 32);
                tp += 8;
                /* DIR OUT,hdrlen-40-8 */
                *tp++=0x01000000 | ((-48u+hdrlen)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR OUT,hdrlen-8-8                  ; bypass rest of the IPv6 header (hdrlen includes the UDP length) */
                *tp++=0x01000000 | ((-16u+hdrlen)&0x1ffffu)<<0;
            }
        }
        else
        {
            prev_nhoffset = EVAL_prev_nhoffset();
            /* IPV6 OUT,nh,00                      ; bypass IPv6 header and restore the next header */
            *tp++=0x81000000 | ((nh)&0xffu)<<16 | ((0u)&0xffffu)<<0;
            is_nat = EVAL_is_nat();
            if (is_nat != 0u)
            {
                /* REPL OUT,ORIG_TOKEN,32 */
                *tp++=0x31d80000 | ((32u)&0x1ffffu)<<0;
                tunnel_ip_addr = EVAL_tunnel_ip_addr();
                TokenBuilder_CopyBytes(tp, tunnel_ip_addr, 32);
                tp += 8;
                /* DIR OUT,prev_nhoffset-40 */
                *tp++=0x01000000 | ((-40u+prev_nhoffset)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR OUT,prev_nhoffset-8   ; bypass rest of the IPv6 header (hdrlen includes the UDP length) */
                *tp++=0x01000000 | ((-8u+prev_nhoffset)&0x1ffffu)<<0;
            }
            /* REPL OUT,ORIG_TOKEN,1               ; zeroise the NH byte of the last extension header */
            *tp++=0x31d80000 | ((1u)&0x1ffffu)<<0;
            /* DATA32 00                           ; */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DIR OUT,hdrlen-prev_nhoffset-1-8    ; bypass the rest data of the last extension header */
            *tp++=0x01000000 | ((-9u+hdrlen-prev_nhoffset)&0x1ffffu)<<0;
        }
        /* REM 8                                   ; remove UDP NAT-T header */
        *tp++=0x40d80000 | ((8u)&0x1ffffu)<<0;
        break;
    case 13: /* ipv4_out_dtls */
        /* IPV4CHK OUT,nh,outlen+hdrlen */
        nh = EVAL_nh();
        outlen = EVAL_outlen();
        *tp++=0x61000000 | ((nh)&0xffu)<<16 | ((outlen+hdrlen)&0xffffu)<<0;
        if (nh == 136u)
        {
            /* DIR OUT,hdrlen-12 */
            *tp++=0x01000000 | ((-12u+hdrlen)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR OUT, hdrlen-16 */
            *tp++=0x01000000 | ((-16u+hdrlen)&0x1ffffu)<<0;
            /* REPL OUT,ORIG_TOKEN,2 */
            *tp++=0x31d80000 | ((2u)&0x1ffffu)<<0;
            /* SWAP16 outlen+8 ; include 8 bytes UDP header */
            *tp++ = ByteSwap16(8u+outlen);
            /* DIR OUT,2 */
            *tp++=0x01000000 | ((2u)&0x1ffffu)<<0;
        }
        break;
    case 33: /* ipv6_out_dtls */
        /* IPV6 OUT,prev_nhoffset,outlen+hdrlen-40 */
        prev_nhoffset = EVAL_prev_nhoffset();
        outlen = EVAL_outlen();
        *tp++=0x81000000 | ((prev_nhoffset)&0xffu)<<16 | ((-40u+outlen+hdrlen)&0xffffu)<<0;
        nh = EVAL_nh();
        if (nh == 136u)
        {
            /* DIR OUT,hdrlen-8 */
            *tp++=0x01000000 | ((-8u+hdrlen)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR OUT, hdrlen-12 */
            *tp++=0x01000000 | ((-12u+hdrlen)&0x1ffffu)<<0;
            /* REPL OUT,ORIG_TOKEN,2 */
            *tp++=0x31d80000 | ((2u)&0x1ffffu)<<0;
            /* SWAP16 outlen+8 ; include 8 bytes UDP header */
            *tp++ = ByteSwap16(8u+outlen);
            /* DIR OUT,2 */
            *tp++=0x01000000 | ((2u)&0x1ffffu)<<0;
        }
        break;
    }
#endif
#endif
    switch(proto)
    {
    case 0: /* esp_out */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        if (ivhandling == 2u)
        {
            /* INS      HASH,ORIG_SPI,8 */
            *tp++=0x23900000 | ((8u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_IV1,ivlen */
            ivlen = EVAL_ivlen();
            *tp++=0x23a80000 | ((ivlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      HASH,ORIG_SPI,8+ivlen */
            ivlen = EVAL_ivlen();
            *tp++=0x23900000 | ((8u+ivlen)&0x1ffffu)<<0;
        }
        /* DIR      CRYPTHASH,packetsize-bypass-hdrlen */
        *tp++=0x07000000 | ((packetsize-bypass-hdrlen)&0x1ffffu)<<0;
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq == 0u)
            {
                /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
                nextheader = EVAL_nextheader();
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2f220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            else
            {
                /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST */
                nextheader = EVAL_nextheader();
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2f200000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
                /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2,4,LASTHASH */
                *tp++=0x224a0000 | ((4u)&0x1ffffu)<<0;
            }
            /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      CRYPT,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASHPKT */
            nextheader = EVAL_nextheader();
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2d260000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        }
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq */
        seq_offset = EVAL_seq_offset();
        extseq = EVAL_extseq();
        *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 1: /* esp_in */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound\n");
            rc = TKB_BAD_PACKET; goto error;
        }
#if TKB_HAVE_ECN_FIXUP == 1u
        /* DATA32 ecn_fixup_instr */
        ecn_fixup_instr = EVAL_ecn_fixup_instr();
        *tp++=0x00000000 | ((ecn_fixup_instr)&0xffffffffu)<<0;
#endif
        if (ivhandling == 0u)
        {
            /* RETR     HASHONLY,ORIG_SPI,8 */
            *tp++=0x42900000 | ((8u)&0x1ffffu)<<0;
            /* RETR     HASHONLY,ORIG_IV1,ivlen */
            *tp++=0x42a80000 | ((ivlen)&0x1ffffu)<<0;
        }
        else
        {
            /* RETR     HASHONLY,ORIG_SPI,8+ivlen */
            *tp++=0x42900000 | ((8u+ivlen)&0x1ffffu)<<0;
        }
        if (icvlen > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq != 1u)
            {
                /* DIR   CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass - hdrlen,LAST,LASTHASH */
                *tp++=0x0f020000 | ((-8u+packetsize-ivlen-icvlen-bypass-hdrlen)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR   CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass - hdrlen,LAST */
                *tp++=0x0f000000 | ((-8u+packetsize-ivlen-icvlen-bypass-hdrlen)&0x1ffffu)<<0;
                /* INS   HASHONLY, ORIG_EXTSEQNUM_RES2,4,LASTHASH */
                *tp++=0x224a0000 | ((4u)&0x1ffffu)<<0;
            }
            /* RETR  NONE,ORIG_HASH,icvlen,LASTHASHPKT */
            *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR CRYPT,packetsize - ivlen - 8 - icvlen - bypass - hdrlen,LAST,LASTHASHPKT */
            *tp++=0x0d060000 | ((-8u+packetsize-ivlen-icvlen-bypass-hdrlen)&0x1ffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 2: /* esp_out_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound CCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* INS      HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32   salt */
        salt = EVAL_salt();
        *tp++=0x00000000 | ((salt)&0xffffffffu)<<0;
        /* INS      HASHONLY,ORIG_IV1,8 */
        *tp++=0x22a80000 | ((8u)&0x1ffffu)<<0;
        /* INS      HASHONLY,ORIG_TOKEN,6     ; Insert message length + AAD length. */
        *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
        /* DATA32 swaplen                     ; Message length, byte-swapped */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* DATA32   0x0800  ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((2048u)&0xffffffffu)<<0;
            /* INS      HASH,ORIG_SPI,8 */
            *tp++=0x23900000 | ((8u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 6 */
            *tp++=0x22000000 | ((0u)&0x1u)<<16 | ((6u)&0xffffu)<<0;
        }
        else
        {
            /* DATA32   0x0c00 ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((3072u)&0xffffffffu)<<0;
            /* INS      HASH,ORIG_SPI,4 */
            *tp++=0x23900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_SEQNUM_RES, 4 */
            *tp++=0x23980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 2 */
            *tp++=0x22000000 | ((0u)&0x1u)<<16 | ((2u)&0xffffu)<<0;
        }
        /* INS      OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+ohdrlen+8+ivlen, 16 */
        ohdrlen = EVAL_ohdrlen();
        *tp++=0xa0000000 | ((8u+bypass+ohdrlen+ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR      CRYPTHASH, packetsize-bypass-hdrlen */
        *tp++=0x07000000 | ((packetsize-bypass-hdrlen)&0x1ffffu)<<0;
        hashpad = EVAL_hashpad();
        if (hashpad == 0u)
        {
            /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
            nextheader = EVAL_nextheader();
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2f220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        }
        else
        {
            /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST */
            nextheader = EVAL_nextheader();
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2f200000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            /* INS      HASHONLY,PAD_ZERO,0,hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0x1u)<<16 | ((hashpad)&0xffffu)<<0;
        }
        /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 3: /* esp_in_ccm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound CCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound CCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* RETR     NONE,ORIG_SPI,8 */
        *tp++=0x40900000 | ((8u)&0x1ffffu)<<0;
        /* RETR     NONE,ORIG_IV1,ivlen */
        *tp++=0x40a80000 | ((ivlen)&0x1ffffu)<<0;
        /* INS      HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32   salt */
        salt = EVAL_salt();
        *tp++=0x00000000 | ((salt)&0xffffffffu)<<0;
        /* INS      HASHONLY,ORIG_IV1,8 */
        *tp++=0x22a80000 | ((8u)&0x1ffffu)<<0;
        /* INS      HASHONLY,ORIG_TOKEN,6    ; Insert message length + AAD length. */
        *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
        /* DATA32 swaplen                    ; Message length, byte-swapped */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            /* DATA32 0x0800  ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((2048u)&0xffffffffu)<<0;
            /* INS      HASHONLY,ORIG_SPI,8 */
            *tp++=0x22900000 | ((8u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 6 */
            *tp++=0x22000000 | ((0u)&0x1u)<<16 | ((6u)&0xffffu)<<0;
        }
        else
        {
            /* DATA32 0x0c00 ; AAD length, byte-swapped */
            *tp++=0x00000000 | ((3072u)&0xffffffffu)<<0;
            /* INS      HASHONLY,ORIG_SPI,4 */
            *tp++=0x22900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_SEQNUM_RES, 4 */
            *tp++=0x22980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, PAD_ZERO, 0, 2 */
            *tp++=0x22000000 | ((0u)&0x1u)<<16 | ((2u)&0xffffu)<<0;
        }
        /* REMRES   bypass+ohdrlen, 16 */
        ohdrlen = EVAL_ohdrlen();
        *tp++=0xa0000000 | ((bypass+ohdrlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
#if TKB_HAVE_ECN_FIXUP == 1u
        /* DATA32 ecn_fixup_instr */
        ecn_fixup_instr = EVAL_ecn_fixup_instr();
        *tp++=0x00000000 | ((ecn_fixup_instr)&0xffffffffu)<<0;
#endif
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        hashpad = EVAL_hashpad();
        if (hashpad == 0u)
        {
            /* DIR      CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass - hdrlen,LAST,LASTHASH */
            *tp++=0x0f020000 | ((-8u+packetsize-ivlen-icvlen-bypass-hdrlen)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR      CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass - hdrlen,LAST */
            *tp++=0x0f000000 | ((-8u+packetsize-ivlen-icvlen-bypass-hdrlen)&0x1ffffu)<<0;
            /* INS      HASHONLY,PAD_ZERO,0,hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0x1u)<<16 | ((hashpad)&0xffffu)<<0;
        }
        /* RETR     NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 4: /* esp_out_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound GCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* INS      HASH,ORIG_SPI,8,LAST */
            *tp++=0x2b900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      HASH,ORIG_SPI,4 */
            *tp++=0x23900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_SEQNUM_RES, 4, LAST */
            *tp++=0x2b980000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS      OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+ohdrlen+8+ivlen, 16 */
        ohdrlen = EVAL_ohdrlen();
        *tp++=0xa0000000 | ((8u+bypass+ohdrlen+ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR      CRYPTHASH, packetsize-bypass-hdrlen */
        *tp++=0x07000000 | ((packetsize-bypass-hdrlen)&0x1ffffu)<<0;
        /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
        nextheader = EVAL_nextheader();
        pad_bytes = EVAL_pad_bytes();
        *tp++=0x2f220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 5: /* esp_in_gcm */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound GCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound GCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            /* RETR     HASHONLY,ORIG_SPI,8,LAST */
            *tp++=0x4a900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* RETR     HASHONLY,ORIG_SPI,4 */
            *tp++=0x42900000 | ((4u)&0x1ffffu)<<0;
            /* RETR     NONE,ORIG_SEQNUM_RES,4 */
            *tp++=0x40980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_SEQNUM_RES,4,LAST */
            *tp++=0x2a980000 | ((4u)&0x1ffffu)<<0;
        }
        /* RETR     NONE,ORIG_IV1,ivlen */
        *tp++=0x40a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+ohdrlen, 16 */
        ohdrlen = EVAL_ohdrlen();
        *tp++=0xa0000000 | ((bypass+ohdrlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
#if TKB_HAVE_ECN_FIXUP == 1u
        /* DATA32 ecn_fixup_instr */
        ecn_fixup_instr = EVAL_ecn_fixup_instr();
        *tp++=0x00000000 | ((ecn_fixup_instr)&0xffffffffu)<<0;
#endif
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR      CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass - hdrlen,LAST,LASTHASH */
        *tp++=0x0f020000 | ((-8u+packetsize-ivlen-icvlen-bypass-hdrlen)&0x1ffffu)<<0;
        /* RETR     NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 6: /* esp_out_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound GMAC\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* INS      HASH,ORIG_SPI,8 */
            *tp++=0x23900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      HASH,ORIG_SPI,4 */
            *tp++=0x23900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_SEQNUM_RES, 4 */
            *tp++=0x23980000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS      HASH,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x23a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+ohdrlen+8+ivlen, 16 */
        ohdrlen = EVAL_ohdrlen();
        *tp++=0xa0000000 | ((8u+bypass+ohdrlen+ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR      HASH, packetsize-bypass-hdrlen */
        *tp++=0x03000000 | ((packetsize-bypass-hdrlen)&0x1ffffu)<<0;
        /* INS      HASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
        nextheader = EVAL_nextheader();
        pad_bytes = EVAL_pad_bytes();
        *tp++=0x2b220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 7: /* esp_in_gmac */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound GMAC\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound GMAC\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            /* RETR     HASHONLY,ORIG_SPI,8 */
            *tp++=0x42900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* RETR     HASHONLY,ORIG_SPI,4 */
            *tp++=0x42900000 | ((4u)&0x1ffffu)<<0;
            /* RETR     NONE,ORIG_SEQNUM_RES,4 */
            *tp++=0x40980000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_SEQNUM_RES,4 */
            *tp++=0x22980000 | ((4u)&0x1ffffu)<<0;
        }
        /* RETR     HASHONLY,ORIG_IV1,ivlen */
        *tp++=0x42a80000 | ((ivlen)&0x1ffffu)<<0;
        /* REMRES   bypass+ohdrlen, 16 */
        ohdrlen = EVAL_ohdrlen();
        *tp++=0xa0000000 | ((bypass+ohdrlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
#if TKB_HAVE_ECN_FIXUP == 1u
        /* DATA32 ecn_fixup_instr */
        ecn_fixup_instr = EVAL_ecn_fixup_instr();
        *tp++=0x00000000 | ((ecn_fixup_instr)&0xffffffffu)<<0;
#endif
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR      HASH,packetsize - ivlen - 8 - icvlen - bypass - hdrlen,LAST,LASTHASH */
        *tp++=0x0b020000 | ((-8u+packetsize-ivlen-icvlen-bypass-hdrlen)&0x1ffffu)<<0;
        /* RETR     NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 8: /* ssltls_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        if (packetsize < bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS outbound\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        capwap_out = EVAL_capwap_out();
        if (capwap_out != 0u)
        {
            /* INS OUT,ORIG_TOKEN,4 */
            *tp++=0x21d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 0x0000001  ; Insert DTLS/CAPWAP header. */
            *tp++=0x00000000 | ((1u)&0xffffffffu)<<0;
        }
        /* INS HASHONLY,ORIG_EXTSEQNUM,4 */
        *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_SEQNUM,4 */
        *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
        /* INS HASH,PAD_CONST,nextheader,1 ; Type field */
        nextheader = EVAL_nextheader();
        *tp++=0x23100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay != 0u)
        {
            /* INS HASH,ORIG_SPI,2          ; For TLS/DTLS, hash version field. */
            *tp++=0x23900000 | ((2u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,ORIG_SPI,2           ; For SSL, do not hash version field. */
            *tp++=0x21900000 | ((2u)&0x1ffffu)<<0;
        }
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* INS OUT,ORIG_EXTSEQNUM,4 */
            *tp++=0x21580000 | ((4u)&0x1ffffu)<<0;
            /* INS OUT,ORIG_SEQNUM,4 */
            *tp++=0x21500000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_TOKEN,2 */
        *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen                   ; Payload length to hash. */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_TOKEN,2 */
        *tp++=0x21d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swap_fraglen              ; Fragment length to output. */
        swap_fraglen = EVAL_swap_fraglen();
        *tp++=0x00000000 | ((swap_fraglen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_IV0,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a00000 | ((ivlen)&0x1ffffu)<<0;
        if (packetsize != bypass+hdrlen)
        {
            /* DIR CRYPTHASH, packetsize-bypass-hdrlen,LASTHASH */
            *tp++=0x07020000 | ((packetsize-bypass-hdrlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS CRYPTHASH, PAD_ZERO, 0, 0, LASTHASH */
            *tp++=0x27020000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        }
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            /* INS CRYPT,ORIG_HASH,icvlen,LAST,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x2de60000 | ((icvlen)&0x1ffffu)<<0;
            /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
            *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2 */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 1: /* upd_arc4 */
            /* INS CRYPT,ORIG_HASH,icvlen,LAST,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x2de60000 | ((icvlen)&0x1ffffu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2 */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM,iv_offset,1,P ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce1800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P   ; Update ARC4 state. */
            *tp++=0xe0d61800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
            if (antireplay != 0u)
            {
                /* INS CRYPT,PAD_TLS,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            else
            {
                /* INS CRYPT,PAD_SSL,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d360000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            /* CTX ORIG_SEQNUM,seq_offset,2 */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_IV0,iv_offset,2,P */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
            if (antireplay != 0u)
            {
                /* INS CRYPT,PAD_TLS,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            else
            {
                /* INS CRYPT,PAD_SSL,0,pad_bytes,LAST,LASTHASHPKT */
                pad_bytes = EVAL_pad_bytes();
                *tp++=0x2d360000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            }
            /* CTX ORIG_SEQNUM,seq_offset,2 */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            /* CTX ORIG_IV0,iv_offset,4,P */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        case 4: /* upd_blk */
            /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
            /* INS CRYPT,PAD_TLS,0,pad_bytes,LAST,LASTHASHPKT */
            pad_bytes = EVAL_pad_bytes();
            *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
            /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
            *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2 */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 9: /* ssltls_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        paylen = EVAL_paylen();
        if (paylen == 4294967295u)
        {
            LOG_WARN("TokenBuilder: bad packet, payload size for SSLTLS inbound\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        upd_handling = EVAL_upd_handling();
        if (upd_handling <= 1u)
        {
            if (bypass > 0u)
            {
                /* DIR OUT,bypass */
                *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
            }
            if (hdrlen > 0u)
            {
                /* DIR OUT,hdrlen */
                *tp++=0x01000000 | ((hdrlen)&0x1ffffu)<<0;
            }
            capwap_in = EVAL_capwap_in();
            if (capwap_in != 0u)
            {
                /* REM 4  ; Remove DTLS/CAPWAP header. */
                *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
            }
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                ohdrlen = EVAL_ohdrlen();
                if (ohdrlen > hdrlen)
                {
                    /* RETR OUT,ORIG_SPI,3    ; Extract Type and Version. */
                    *tp++=0x41900000 | ((3u)&0x1ffffu)<<0;
                    /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
                    *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
                    /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
                    *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
                    /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
                    *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
                    /* INS HASH,ORIG_TOKEN,2 */
                    *tp++=0x23d80000 | ((2u)&0x1ffffu)<<0;
                    /* DATA32 swaplen */
                    swaplen = EVAL_swaplen();
                    *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
                    if (ohdrlen-hdrlen > 5u)
                    {
                        /* INS OUT,PAD_ZERO,0,ohdrlen-hdrlen-5 */
                        *tp++=0x21000000 | ((0u)&0x1u)<<16 | ((-5u+ohdrlen-hdrlen)&0xffffu)<<0;
                    }
                }
                else
                {
                    /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
                    *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
                    /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
                    *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
                    /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
                    *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
                    /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
                    *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
                    /* INS HASHONLY,ORIG_TOKEN,2 */
                    *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
                    /* DATA32 swaplen */
                    swaplen = EVAL_swaplen();
                    *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
                }
            }
            else
            {
                /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
                *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SEQNUM,4 */
                *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* DIR HASHONLY,3       ; Hash type and version number */
                    *tp++=0x02000000 | ((3u)&0x1ffffu)<<0;
                }
                else
                {
                    /* DIR HASHONLY,1       ; Hash type only for SSL */
                    *tp++=0x02000000 | ((1u)&0x1ffffu)<<0;
                    /* REM 2 */
                    *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
                }
                /* INS HASHONLY,ORIG_TOKEN,2 */
                *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
                /* DATA32 swaplen */
                swaplen = EVAL_swaplen();
                *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
            }
            /* REM 2                              ; Remove fragment length. */
            *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            /* REMRES bypass+ohdrlen+paylen,icvlen          ; Cause the MAC to be removed */
            ohdrlen = EVAL_ohdrlen();
            icvlen = EVAL_icvlen();
            *tp++=0xa0000000 | ((bypass+ohdrlen+paylen)&0xffffu)<<0 | ((icvlen)&0x3fu)<<19;
            /* DIR CRYPTHASH,paylen,LASTHASH */
            *tp++=0x07020000 | ((paylen)&0x1ffffu)<<0;
            switch(upd_handling)
            {
            case 0: /* upd_null */
                /* DIR CRYPT,icvlen,LAST,LASTHASHPKT */
                *tp++=0x0d060000 | ((icvlen)&0x1ffffu)<<0;
                if (extseq == 0u)
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,2,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                }
                else if (extseq == 1u)
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,S,H */
                    *tp++=0xd8070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
                }
                break;
            case 1: /* upd_arc4 */
                /* DIR CRYPT,icvlen,LAST,LASTHASHPKT */
                *tp++=0x0d060000 | ((icvlen)&0x1ffffu)<<0;
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                /* CTX ORIG_CHKSUM,iv_offset,1,P ; Update IJ pointer */
                iv_offset = EVAL_iv_offset();
                *tp++=0xe0ce1800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
                /* CTX ORIG_CHKSUM_STORE,0,1,P   ; Update ARC4 state. */
                *tp++=0xe0d61800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
                break;
            }
        }
        else
        {
            /* REMRES 0,4,NOUPDCHK */
            *tp++=0xa0020000 | ((0u)&0xffffu)<<0 | ((4u)&0x3fu)<<19;
            cipher_is_aes = EVAL_cipher_is_aes();
            if (cipher_is_aes == 0u)
            {
                /* INS CRYPTONLY,ORIG_TOKEN,12 */
                *tp++=0x24d80000 | ((12u)&0x1ffffu)<<0;
                ssltls_lastblock = EVAL_ssltls_lastblock();
                TokenBuilder_CopyBytes(tp, ssltls_lastblock, 12);
                tp += 3;
                /* INS CRYPT,ORIG_TOKEN,4 */
                *tp++=0x25d80000 | ((4u)&0x1ffffu)<<0;
                ssltls_lastword = EVAL_ssltls_lastword();
                TokenBuilder_CopyBytes(tp, ssltls_lastword, 4);
                tp += 1;
            }
            else
            {
                /* INS CRYPTONLY,ORIG_TOKEN,28 */
                *tp++=0x24d80000 | ((28u)&0x1ffffu)<<0;
                ssltls_lastblock = EVAL_ssltls_lastblock();
                TokenBuilder_CopyBytes(tp, ssltls_lastblock, 28);
                tp += 7;
                /* INS CRYPT,ORIG_TOKEN,4 */
                *tp++=0x25d80000 | ((4u)&0x1ffffu)<<0;
                ssltls_lastword = EVAL_ssltls_lastword();
                TokenBuilder_CopyBytes(tp, ssltls_lastword, 4);
                tp += 1;
            }
            /* DIR NONE,0,LAST */
            *tp++=0x08000000 | ((0u)&0x1ffffu)<<0;
            if (bypass+hdrlen > 0u)
            {
                /* DIR OUT,bypass+hdrlen */
                *tp++=0x01000000 | ((bypass+hdrlen)&0x1ffffu)<<0;
            }
            capwap_in = EVAL_capwap_in();
            if (capwap_in != 0u)
            {
                /* REM 4  ; Remove DTLS/CAPWAP header. */
                *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
            }
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                ohdrlen = EVAL_ohdrlen();
                if (ohdrlen > hdrlen)
                {
                    /* RETR OUT,ORIG_SPI,3    ; Extract Type and Version. */
                    *tp++=0x41900000 | ((3u)&0x1ffffu)<<0;
                    /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
                    *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
                    /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
                    *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
                    /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
                    *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
                    /* INS HASH,ORIG_LENCOR,paylen-1 */
                    *tp++=0x23780000 | ((-1u+paylen)&0x1ffffu)<<0;
                    if (ohdrlen-hdrlen > 5u)
                    {
                        /* INS OUT,PAD_ZERO,0,ohdrlen-hdrlen-5 */
                        *tp++=0x21000000 | ((0u)&0x1u)<<16 | ((-5u+ohdrlen-hdrlen)&0xffffu)<<0;
                    }
                }
                else
                {
                    /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
                    *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
                    /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
                    *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
                    /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
                    *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
                    /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
                    *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
                    /* INS HASHONLY,ORIG_LENCOR,paylen-1 */
                    *tp++=0x22780000 | ((-1u+paylen)&0x1ffffu)<<0;
                }
            }
            else
            {
                /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
                *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
                *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SEQNUM,4 */
                *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* INS HASHONLY,ORIG_SPI_RES,3       ; Hash type and version number */
                    *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
                }
                else
                {
                    /* INS HASHONLY,ORIG_SPI_RES,1       ; Hash type only. */
                    *tp++=0x22c00000 | ((1u)&0x1ffffu)<<0;
                }
                /* INS HASHONLY,ORIG_LENCOR,paylen-1 */
                *tp++=0x22780000 | ((-1u+paylen)&0x1ffffu)<<0;
            }
            /* REM 2                              ; Remove fragment length. */
            *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            ivlen = EVAL_ivlen();
            if (ivlen > 0u)
            {
                /* RETR NONE,ORIG_IV0,ivlen */
                *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
            }
            /* REMRES bypass+ohdrlen,icvlen,NOUPDCHK          ; Cause the MAC to be removed */
            ohdrlen = EVAL_ohdrlen();
            icvlen = EVAL_icvlen();
            *tp++=0xa0020000 | ((bypass+ohdrlen)&0xffffu)<<0 | ((icvlen)&0x3fu)<<19;
            /* DIRX CRYPTHASH,ORIG_LENCOR,0,LASTHASH */
            *tp++=0x077a0000 | ((0u)&0x1ffffu)<<0;
            /* DIRX CRYPT,ORIG_LENCOR,icvlen+1,LAST,LASTHASHPKT */
            *tp++=0x0d7e0000 | ((1u+icvlen)&0x1ffffu)<<0;
            switch(upd_handling)
            {
            case 2: /* upd_iv2 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                }
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                /* CTX ORIG_IV0,iv_offset,2,P */
                iv_offset = EVAL_iv_offset();
                *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                break;
            case 3: /* upd_iv4 */
                antireplay = EVAL_antireplay();
                if (antireplay != 0u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,H */
                    *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
                }
                /* CTX ORIG_SEQNUM,seq_offset,2,P */
                seq_offset = EVAL_seq_offset();
                *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                /* CTX ORIG_IV0,iv_offset,4,P */
                iv_offset = EVAL_iv_offset();
                *tp++=0xe0a61800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
                break;
            case 4: /* upd_blk */
                if (extseq == 0u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,2,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
                }
                else if (extseq == 1u)
                {
                    /* VERIFY icvlen,P,H */
                    *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
                }
                else
                {
                    /* VERIFY icvlen,P,S,H */
                    *tp++=0xd9070000 | ((icvlen)&0x7fu)<<0;
                    /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
                }
                break;
            }
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 21: /* ssltls_gcm_out */
    case 37: /* ssltls_chachapoly_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        if (packetsize < bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS outbound GCM or ChaChaPoly\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        capwap_out = EVAL_capwap_out();
        if (capwap_out != 0u)
        {
            /* INS OUT,ORIG_TOKEN,4 */
            *tp++=0x21d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 0x0000001  ; Insert DTLS/CAPWAP header. */
            *tp++=0x00000000 | ((1u)&0xffffffffu)<<0;
        }
        /* INS HASHONLY,ORIG_EXTSEQNUM,4 */
        *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_SEQNUM,4 */
        *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
        /* INS HASH,PAD_CONST,nextheader,1 ; Type field */
        nextheader = EVAL_nextheader();
        *tp++=0x23100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASH,ORIG_SPI,2          ; For TLS/DTLS, hash version field. */
        *tp++=0x23900000 | ((2u)&0x1ffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* INS OUT,ORIG_EXTSEQNUM,4 ; Output sequence number for DTLS */
            *tp++=0x21580000 | ((4u)&0x1ffffu)<<0;
            /* INS OUT,ORIG_SEQNUM,4 */
            *tp++=0x21500000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_TOKEN,2,LAST */
        *tp++=0x2ad80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen                   ; Payload length to hash. */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_TOKEN,2 */
        *tp++=0x21d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swap_fraglen              ; Fragment length to output. */
        swap_fraglen = EVAL_swap_fraglen();
        *tp++=0x00000000 | ((swap_fraglen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        if (proto != 37u)
        {
            if (extseq != 0u)
            {
                /* REMRES bypass + hdrlen + capwap_out + 5 + 8 + 8, 16 */
                *tp++=0xa0000000 | ((21u+bypass+hdrlen+capwap_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            }
            else
            {
                /* REMRES bypass + hdrlen + 5 + 8, 16 */
                *tp++=0xa0000000 | ((13u+bypass+hdrlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            }
            /* INS CRYPT, PAD_ZERO, 0, 16 */
            *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        }
        if (packetsize != bypass+hdrlen)
        {
            /* DIR CRYPTHASH, packetsize-bypass-hdrlen,LAST,LASTHASH */
            *tp++=0x0f020000 | ((packetsize-bypass-hdrlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS CRYPTHASH, PAD_ZERO, 0, 0, LAST, LASTHASH */
            *tp++=0x2f020000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        }
        /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX ORIG_SEQNUM,seq_offset,2 */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 22: /* ssltls_gcm_in */
    case 38: /* ssltls_chachapoly_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        paylen = EVAL_paylen();
        if (paylen == 4294967295u)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS inbound GCM or ChaChaPoly\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        if (hdrlen > 0u)
        {
            /* DIR OUT,hdrlen */
            *tp++=0x01000000 | ((hdrlen)&0x1ffffu)<<0;
        }
        capwap_in = EVAL_capwap_in();
        if (capwap_in != 0u)
        {
            /* REM 4  ; Remove DTLS/CAPWAP header. */
            *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
        }
        ohdrlen = EVAL_ohdrlen();
        if (ohdrlen > hdrlen)
        {
            /* RETR OUT,ORIG_SPI,3    ; Extract Type and Version. */
            *tp++=0x41900000 | ((3u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
            *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
            *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
            /* REM 2                    ; Remove fragment length. */
            *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            /* RETR NONE,ORIG_IV1,ivlen */
            ivlen = EVAL_ivlen();
            *tp++=0x40a80000 | ((ivlen)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
            *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
            /* INS HASH,ORIG_TOKEN,2,LAST */
            *tp++=0x2bd80000 | ((2u)&0x1ffffu)<<0;
            /* DATA32 swaplen */
            swaplen = EVAL_swaplen();
            *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
            if (ohdrlen-hdrlen > 5u)
            {
                /* INS OUT,PAD_ZERO,0,ohdrlen-hdrlen-5 */
                *tp++=0x21000000 | ((0u)&0x1u)<<16 | ((-5u+ohdrlen-hdrlen)&0xffffu)<<0;
            }
        }
        else
        {
            /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
            *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                /* RETR HASHONLY,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
                *tp++=0x42480000 | ((4u)&0x1ffffu)<<0;
                /* RETR HASHONLY,ORIG_SEQNUM_RES2,4 */
                *tp++=0x42400000 | ((4u)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
                *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SEQNUM,4 */
                *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
            }
            /* REM 2                    ; Remove fragment length. */
            *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            /* RETR NONE,ORIG_IV1,ivlen */
            ivlen = EVAL_ivlen();
            *tp++=0x40a80000 | ((ivlen)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
            *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_TOKEN,2,LAST */
            *tp++=0x2ad80000 | ((2u)&0x1ffffu)<<0;
            /* DATA32 swaplen */
            swaplen = EVAL_swaplen();
            *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        }
        if (proto != 38u)
        {
            /* REMRES bypass+ohdrlen, 16 */
            *tp++=0xa0000000 | ((bypass+ohdrlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            /* INS CRYPT, PAD_ZERO, 0, 16 */
            *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        }
        else
        {
#if TKB_HAVE_CHACHAPOLY_HW30 == 1u
            /* INS NONE, PAD_ZERO, 0, 160 */
            *tp++=0x20000000 | ((0u)&0x1u)<<16 | ((160u)&0xffffu)<<0;
#else
            /* INS NONE, PAD_ZERO, 0, 16 */
            *tp++=0x20000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
#endif
        }
        /* DIR CRYPTHASH, paylen,LAST,LASTHASH */
        *tp++=0x0f020000 | ((paylen)&0x1ffffu)<<0;
        /* RETR NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* VERIFY icvlen,H */
            *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
        }
        else if (extseq == 1u)
        {
            /* VERIFY icvlen,H */
            *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
        }
        else
        {
            /* VERIFY icvlen,S,H */
            *tp++=0xd8070000 | ((icvlen)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 10: /* basic_crypto */
#if TKB_HAVE_PROTO_BASIC == 1u
        ivlen = EVAL_ivlen();
        if (packetsize < ivlen+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic crypto\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR NONE,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x40a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 1: /* iv_inbound_cbc */
            /* RETR NONE,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 2: /* iv_outbound_ctr */
            /* INS  OUT,ORIG_IV1,8 */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 5: /* iv_copy_ctr */
            /* RETR OUT,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x41a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 4: /* iv_copy_cbc */
            /* RETR OUT,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x41a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            /* INS  OUT,ORIG_IV0,8 */
            *tp++=0x21a00000 | ((8u)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  OUT,ORIG_IV0,16 */
            *tp++=0x21a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        /* DIR CRYPT,packetsize-ivlen-bypass */
        *tp++=0x05000000 | ((packetsize-ivlen-bypass)&0x1ffffu)<<0;
        /* INS CRYPT,PAD_ZERO,0,pad_bytes_basic,LAST,LASTHASHPKT */
        pad_bytes_basic = EVAL_pad_bytes_basic();
        *tp++=0x2d060000 | ((0u)&0x1u)<<16 | ((pad_bytes_basic)&0xffffu)<<0;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            /* CTX ORIG_CHKSUM,iv_offset,1,P,F ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce3800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P,F   ; Update ARC4 state. */
            *tp++=0xe0d63800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            /* CTX ORIG_IV0,iv_offset,2,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            /* CTX ORIG_IV0,iv_offset,4,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 11: /* basic_hash */
#if TKB_HAVE_PROTO_BASIC == 1u
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic hash\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* DIR HASH,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x03020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASHONLY,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x02020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
            if (hstatelen > 16u)
            {
                /* CTX ORIG_SPI_RES,seq_offset+hstatelen-16,1,P,F ; Update block counter */
                *tp++=0xe0c63800 | ((-16u+seq_offset+hstatelen)&0xffu)<<0 | ((1u)&0xfu)<<24;
            }
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 14: /* basic_crypthash */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic crypthash\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 1: /* iv_inbound_cbc */
            /* RETR HASHONLY,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x42a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 2: /* iv_outbound_ctr */
            /* INS  HASH,ORIG_IV1,8 */
            *tp++=0x23a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 5: /* iv_copy_ctr */
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
            break;
        case 4: /* iv_copy_cbc */
            /* RETR HASH,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x43a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            /* INS  HASH,ORIG_IV0,8 */
            *tp++=0x23a00000 | ((8u)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  HASH,ORIG_IV0,16 */
            *tp++=0x23a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        pad_bytes_basic = EVAL_pad_bytes_basic();
        if (pad_bytes_basic > 0u)
        {
            /* DIR CRYPTHASH,packetsize-ivlen-bypass-aadlen_pkt-antireplay */
            *tp++=0x07000000 | ((packetsize-ivlen-bypass-aadlen_pkt-antireplay)&0x1ffffu)<<0;
            /* INS CRYPTHASH,PAD_ZERO,0,pad_bytes_basic,LAST,LASTHASH */
            *tp++=0x2f020000 | ((0u)&0x1u)<<16 | ((pad_bytes_basic)&0xffffu)<<0;
        }
        else
        {
            /* DIR CRYPTHASH,packetsize-ivlen-bypass-aadlen_pkt-antireplay,LAST,LASTHASH */
            *tp++=0x0f020000 | ((packetsize-ivlen-bypass-aadlen_pkt-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
            if (hstatelen > 16u)
            {
                /* CTX ORIG_SPI_RES,seq_offset+hstatelen-16,1,P,F ; Update block counter */
                *tp++=0xe0c63800 | ((-16u+seq_offset+hstatelen)&0xffu)<<0 | ((1u)&0xfu)<<24;
            }
        }
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 1: /* upd_arc4 */
            /* CTX ORIG_CHKSUM,iv_offset,1,P,F ; Update IJ pointer */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0ce3800 | ((iv_offset)&0xffu)<<0 | ((1u)&0xfu)<<24;
            /* CTX ORIG_CHKSUM_STORE,0,1,P,F   ; Update ARC4 state. */
            *tp++=0xe0d63800 | ((0u)&0xffu)<<0 | ((1u)&0xfu)<<24;
            break;
        case 2: /* upd_iv2 */
            /* CTX ORIG_IV0,iv_offset,2,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
            break;
        case 3: /* upd_iv4 */
            /* CTX ORIG_IV0,iv_offset,4,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 15: /* basic_out_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out ccm\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* INS HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32 basic_salt */
        basic_salt = EVAL_basic_salt();
        *tp++=0x00000000 | ((basic_salt)&0xffffffffu)<<0;
        if (ivhandling == 5u)
        {
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS HASH, ORIG_IV1,8 */
            *tp++=0x23a80000 | ((8u)&0x1ffffu)<<0;
        }
        aadlen_swap = EVAL_aadlen_swap();
        if (aadlen_swap > 0u)
        {
            /* INS HASHONLY,ORIG_TOKEN,6 */
            *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
            /* DATA32 aadlen_swap */
            *tp++=0x00000000 | ((aadlen_swap)&0xffffffffu)<<0;
            aadlen_tkn = EVAL_aadlen_tkn();
            if (aadlen_tkn > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                else
                {
                    /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                aad = EVAL_aad();
                if (aadlen_tkn > 64)
                {
                    LOG_CRIT("Field too large\n");
                    return TKB_BAD_FIELD_SIZE;
                }
                TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
                tp += (aadlen_tkn + 3)/4;
            }
            else if (aadlen_pkt > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* DIR HASH,aadlen_pkt */
                    *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
                else
                {
                    /* DIR HASHONLY,aadlen_pkt */
                    *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
            }
            /* INS HASHONLY,PAD_ZERO,0,aadpad */
            aadpad = EVAL_aadpad();
            *tp++=0x22000000 | ((0u)&0x1u)<<16 | ((aadpad)&0xffffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_TOKEN,4 */
            *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
        }
        /* REMRES bypass+8+aadlen_out,16 */
        aadlen_out = EVAL_aadlen_out();
        *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT,PAD_ZERO,0,16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        basic_hashpad = EVAL_basic_hashpad();
        if (basic_hashpad == 0u)
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass,LAST,LASTHASH */
            *tp++=0x0f020000 | ((packetsize-aadlen_pkt-ivlen-bypass)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass,LAST */
            *tp++=0x0f000000 | ((packetsize-aadlen_pkt-ivlen-bypass)&0x1ffffu)<<0;
            /* INS HASHONLY,PAD_ZERO,0,basic_hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0x1u)<<16 | ((basic_hashpad)&0xffffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* INS OUT, ORIG_HASH, icvlen, LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 16: /* basic_in_ccm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic in ccm\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* INS HASHONLY,ORIG_TOKEN,4 */
        *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
        /* DATA32 basic_salt */
        basic_salt = EVAL_basic_salt();
        *tp++=0x00000000 | ((basic_salt)&0xffffffffu)<<0;
        if (ivhandling == 0u)
        {
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_IV1,8 */
            *tp++=0x22a80000 | ((8u)&0x1ffffu)<<0;
        }
        aadlen_swap = EVAL_aadlen_swap();
        if (aadlen_swap > 0u)
        {
            /* INS HASHONLY,ORIG_TOKEN,6 */
            *tp++=0x22d80000 | ((6u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
            /* DATA32 aadlen_swap */
            *tp++=0x00000000 | ((aadlen_swap)&0xffffffffu)<<0;
            aadlen_tkn = EVAL_aadlen_tkn();
            if (aadlen_tkn > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                else
                {
                    /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                    *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
                }
                aad = EVAL_aad();
                if (aadlen_tkn > 64)
                {
                    LOG_CRIT("Field too large\n");
                    return TKB_BAD_FIELD_SIZE;
                }
                TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
                tp += (aadlen_tkn + 3)/4;
            }
            else if (aadlen_pkt > 0u)
            {
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* DIR HASH,aadlen_pkt */
                    *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
                else
                {
                    /* DIR HASHONLY,aadlen_pkt */
                    *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
                }
            }
            /* INS HASHONLY,PAD_ZERO,0,aadpad */
            aadpad = EVAL_aadpad();
            *tp++=0x22000000 | ((0u)&0x1u)<<16 | ((aadpad)&0xffffu)<<0;
        }
        else
        {
            /* INS HASHONLY,ORIG_TOKEN,4 */
            *tp++=0x22d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 basic_swaplen */
            basic_swaplen = EVAL_basic_swaplen();
            *tp++=0x00000000 | ((basic_swaplen)&0xffffffffu)<<0;
        }
        /* REMRES bypass+aadlen_out,16 */
        aadlen_out = EVAL_aadlen_out();
        *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT,PAD_ZERO,0,16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        basic_hashpad = EVAL_basic_hashpad();
        if (basic_hashpad == 0u)
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass-icvlen,LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0f020000 | ((packetsize-aadlen_pkt-ivlen-bypass-icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass-icvlen,LAST */
            icvlen = EVAL_icvlen();
            *tp++=0x0f000000 | ((packetsize-aadlen_pkt-ivlen-bypass-icvlen)&0x1ffffu)<<0;
            /* INS HASHONLY,PAD_ZERO,0,basic_hashpad,LASTHASH */
            *tp++=0x22020000 | ((0u)&0x1u)<<16 | ((basic_hashpad)&0xffffu)<<0;
        }
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* RETR NONE, ORIG_HASH, antireplay, LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 17: /* basic_out_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out gcm\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2bd80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2ad80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt,LAST */
                *tp++=0x0b000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt,LAST */
                *tp++=0x0a000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR NONE,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x40a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 5: /* iv_copy_ctr */
            if (aadlen_pkt+aadlen_tkn == 0u)
            {
                LOG_WARN("TokenBuilder: bad packet, null aad illegal for gcm and copy iv\n");
                rc = TKB_BAD_PACKET; goto error;
            }
            /* RETR OUT,ORIG_IV1,8 ; IV from input packet, copy iv */
            *tp++=0x41a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            if (aadlen_pkt+aadlen_tkn == 0u)
            {
                LOG_WARN("TokenBuilder: bad packet, null aad illegal for gcm and copy iv\n");
                rc = TKB_BAD_PACKET; goto error;
            }
            /* INS OUT,ORIG_IV1,8 ; IV from token, copy iv */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        default:
            /* REMRES   bypass+aadlen_out,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR      CRYPTHASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
        *tp++=0x0f020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* INS OUT, ORIG_HASH, icvlen, LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 18: /* basic_in_gcm */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic in gcm\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2bd80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2ad80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt,LAST */
                *tp++=0x0b000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt,LAST */
                *tp++=0x0a000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR NONE,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x40a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 5: /* iv_copy_ctr */
            if (aadlen_pkt+aadlen_tkn == 0u)
            {
                LOG_WARN("TokenBuilder: bad packet, null aad illegal for gcm and copy iv\n");
                rc = TKB_BAD_PACKET; goto error;
            }
            /* RETR OUT,ORIG_IV1,8 ; IV from input packet, copy iv */
            *tp++=0x41a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            if (aadlen_pkt+aadlen_tkn == 0u)
            {
                LOG_WARN("TokenBuilder: bad packet, null aad illegal for gcm and copy iv\n");
                rc = TKB_BAD_PACKET; goto error;
            }
            /* INS OUT,ORIG_IV1,8 ; IV from token, copy iv */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            /* REMRES   bypass+aadlen_out+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        default:
            /* REMRES   bypass+aadlen_out,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((bypass+aadlen_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS      CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR      CRYPTHASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
        icvlen = EVAL_icvlen();
        *tp++=0x0f020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* RETR NONE, ORIG_HASH, antireplay, LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 19: /* basic_out_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out gmac\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((packetsize+aadlen_out-aadlen_pkt-ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 5: /* iv_copy_ctr */
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, copy iv */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+packetsize+aadlen_out-aadlen_pkt-ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            /* INS OUT,ORIG_IV1,8 ; IV from token, copy iv. */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+packetsize+aadlen_out-aadlen_pkt-ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        default:
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen, LAST,LASTHASH */
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((packetsize+aadlen_out-aadlen_pkt-ivlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS      CRYPT, PAD_ZERO, 0, 16,LAST */
        *tp++=0x2d000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* INS OUT, ORIG_HASH, icvlen, LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 20: /* basic_in_gmac */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+aadlen_pkt+ivlen+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic in gmac\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 0: /* iv_inbound_ctr */
            /* RETR HASHONLY,ORIG_IV1,8 ; IV from input packet, CTR. */
            *tp++=0x42a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 5: /* iv_copy_ctr */
            /* RETR HASH,ORIG_IV1,8 ; IV from input packet, copy iv */
            *tp++=0x43a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        case 15: /* iv_copy_token_4words */
        case 2: /* iv_outbound_ctr */
            /* INS OUT,ORIG_IV1,8 ; IV from token, copy iv Do not authenticate IV */
            *tp++=0x21a80000 | ((8u)&0x1ffffu)<<0;
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen+8,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((8u+packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
            break;
        default:
            /* DIR      HASH,packetsize - bypass - aadlen_pkt - ivlen - icvlen, LAST,LASTHASH */
            icvlen = EVAL_icvlen();
            *tp++=0x0b020000 | ((packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
            /* REMRES   packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen,16 */
            aadlen_out = EVAL_aadlen_out();
            *tp++=0xa0000000 | ((packetsize+aadlen_out-aadlen_pkt-ivlen-icvlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS      CRYPT, PAD_ZERO, 0, 16,LAST */
        *tp++=0x2d000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        seq_offset = EVAL_seq_offset();
        if (seq_offset > 0u)
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
            /* CTX ORIG_HASH,seq_offset,hstatelen,P,F */
            hstatelen = EVAL_hstatelen();
            *tp++=0xe0e63800 | ((seq_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        }
        else
        {
            /* RETR NONE, ORIG_HASH, antireplay, LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 23: /* basic_xts_crypto */
#if TKB_HAVE_CRYPTO_XTS == 1u
        ivlen = EVAL_ivlen();
        if (packetsize < ivlen+bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic crypto\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        swap_j = EVAL_swap_j();
        if (swap_j != 0u)
        {
            /* INSCTX NONE,ORIG_TOKEN,10,16 */
            *tp++=0x90d80000 | ((10u)&0x1fu)<<12 | ((16u)&0x1ffu)<<0;
            /* DATA32 0 */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DATA32 0 */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DATA32 0 */
            *tp++=0x00000000 | ((0u)&0xffffffffu)<<0;
            /* DATA32 swap_j */
            *tp++=0x00000000 | ((swap_j)&0xffffffffu)<<0;
        }
        switch(ivhandling)
        {
        case 1: /* iv_inbound_cbc */
            /* RETR NONE,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 4: /* iv_copy_cbc */
            /* RETR OUT,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x41a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  OUT,ORIG_IV0,16 */
            *tp++=0x21a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        /* DIR CRYPT,packetsize-ivlen-bypass */
        *tp++=0x05000000 | ((packetsize-ivlen-bypass)&0x1ffffu)<<0;
        /* INS CRYPT,PAD_ZERO,0,pad_bytes_basic,LAST,LASTHASHPKT */
        pad_bytes_basic = EVAL_pad_bytes_basic();
        *tp++=0x2d060000 | ((0u)&0x1u)<<16 | ((pad_bytes_basic)&0xffffu)<<0;
        upd_handling = EVAL_upd_handling();
        switch(upd_handling)
        {
        case 0: /* upd_null */
            break;
        case 3: /* upd_iv4 */
            /* CTX ORIG_IV0,iv_offset,4,P,F */
            iv_offset = EVAL_iv_offset();
            *tp++=0xe0a63800 | ((iv_offset)&0xffu)<<0 | ((4u)&0xfu)<<24;
            break;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 24: /* basic_kasumi_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic hash\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* INS HASHONLY,ORIG_TOKEN,8 */
        *tp++=0x22d80000 | ((8u)&0x1ffffu)<<0;
        /* DATA32 count */
        count = EVAL_count();
        *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
        /* DATA32 bearer_dir_fresh */
        bearer_dir_fresh = EVAL_bearer_dir_fresh();
        *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* DIR HASH,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x03020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASHONLY,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x02020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 25: /* basic_snow_hash */
    case 26: /* basic_zuc_hash */
#if TKB_HAVE_CRYPTO_WIRELESS == 1u
        antireplay = EVAL_antireplay();
        if (packetsize < bypass+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic hash\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* INSCTX NONE,ORIG_TOKEN,10,16 */
        *tp++=0x90d80000 | ((10u)&0x1fu)<<12 | ((16u)&0x1ffu)<<0;
        /* DATA32 count */
        count = EVAL_count();
        *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
        /* DATA32 bearer_dir_fresh */
        bearer_dir_fresh = EVAL_bearer_dir_fresh();
        *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        /* DATA32 count */
        *tp++=0x00000000 | ((count)&0xffffffffu)<<0;
        /* DATA32 bearer_dir_fresh */
        *tp++=0x00000000 | ((bearer_dir_fresh)&0xffffffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* DIR HASH,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x03020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASHONLY,packetsize-bypass-antireplay,LASTHASH */
            *tp++=0x02020000 | ((packetsize-bypass-antireplay)&0x1ffffu)<<0;
        }
        appendhash = EVAL_appendhash();
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_HASH,antireplay,LASTHASHPKT */
            *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
            /* VERIFY antireplay,H */
            *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
        }
        else if (appendhash > 0u)
        {
            /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
            icvlen = EVAL_icvlen();
            *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS OUT,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x21060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 27: /* basic_hashenc */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic crypthash\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x23d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn */
                *tp++=0x22d80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt */
                *tp++=0x03000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt */
                *tp++=0x02000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        switch(ivhandling)
        {
        case 4: /* iv_copy_cbc */
            /* RETR OUT,ORIG_IV0,ivlen ; IV from input packet CBC */
            *tp++=0x41a00000 | ((ivlen)&0x1ffffu)<<0;
            break;
        case 6: /* iv_outbound_2words */
        case 9: /* iv_copy_token_2words */
            /* INS  OUT,ORIG_IV0,8 */
            *tp++=0x21a00000 | ((8u)&0x1ffffu)<<0;
            break;
        case 7: /* iv_outbound_4words */
        case 15: /* iv_copy_token_4words */
            /* INS  OUT,ORIG_IV0,16 */
            *tp++=0x21a00000 | ((16u)&0x1ffffu)<<0;
            break;
        }
        /* DIR CRYPTHASH,packetsize-ivlen-bypass-aadlen_pkt,LASTHASH */
        *tp++=0x07020000 | ((packetsize-ivlen-bypass-aadlen_pkt)&0x1ffffu)<<0;
        /* INS CRYPT,ORIG_HASH,icvlen,LASTHASH */
        icvlen = EVAL_icvlen();
        *tp++=0x25e20000 | ((icvlen)&0x1ffffu)<<0;
        /* INS CRYPT,PAD_TLS,0,pad_bytes_hashenc,LAST,LASTHASHPKT */
        pad_bytes_hashenc = EVAL_pad_bytes_hashenc();
        *tp++=0x2d2e0000 | ((0u)&0xffu)<<9 | ((pad_bytes_hashenc)&0x1ffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 28: /* basic_dechash */
#if TKB_HAVE_PROTO_BASIC == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_pkt+aadlen_tkn < 2u)
        {
            LOG_WARN("TokenBuilder: bad packet, aad too short\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* REMRES 0,4,NOUPDCHK */
        *tp++=0xa0020000 | ((0u)&0xffffu)<<0 | ((4u)&0x3fu)<<19;
        cipher_is_aes = EVAL_cipher_is_aes();
        if (cipher_is_aes == 0u)
        {
            ivlen = EVAL_ivlen();
            if (packetsize < 16u+bypass+aadlen_pkt+ivlen)
            {
                LOG_WARN("TokenBuilder: bad packet, too short for basic dechash\n");
                rc = TKB_BAD_PACKET; goto error;
            }
            /* INS CRYPTONLY,ORIG_TOKEN,12 */
            *tp++=0x24d80000 | ((12u)&0x1ffffu)<<0;
            ssltls_lastblock = EVAL_ssltls_lastblock();
            TokenBuilder_CopyBytes(tp, ssltls_lastblock, 12);
            tp += 3;
            /* INS CRYPT,ORIG_TOKEN,4 */
            *tp++=0x25d80000 | ((4u)&0x1ffffu)<<0;
            ssltls_lastword = EVAL_ssltls_lastword();
            TokenBuilder_CopyBytes(tp, ssltls_lastword, 4);
            tp += 1;
        }
        else
        {
            ivlen = EVAL_ivlen();
            if (packetsize < 32u+bypass+aadlen_pkt+ivlen)
            {
                LOG_WARN("TokenBuilder: bad packet, too short for basic dechash\n");
                rc = TKB_BAD_PACKET; goto error;
            }
            /* INS CRYPTONLY,ORIG_TOKEN,28 */
            *tp++=0x24d80000 | ((28u)&0x1ffffu)<<0;
            ssltls_lastblock = EVAL_ssltls_lastblock();
            TokenBuilder_CopyBytes(tp, ssltls_lastblock, 28);
            tp += 7;
            /* INS CRYPT,ORIG_TOKEN,4 */
            *tp++=0x25d80000 | ((4u)&0x1ffffu)<<0;
            ssltls_lastword = EVAL_ssltls_lastword();
            TokenBuilder_CopyBytes(tp, ssltls_lastword, 4);
            tp += 1;
        }
        /* DIR NONE,0,LAST */
        *tp++=0x08000000 | ((0u)&0x1ffffu)<<0;
        if (bypass > 0u)
        {
            /* DIR OUT,bypass */
            *tp++=0x01000000 | ((bypass)&0x1ffffu)<<0;
        }
        if (aadlen_tkn > 0u)
        {
            /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn-2 */
            *tp++=0x22d80000 | ((-2u+aadlen_tkn)&0x1ffffu)<<0;
            aad = EVAL_aad();
            if (-2u+aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, -2u+aadlen_tkn);
            tp += (-2u+aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            /* DIR HASHONLY,aadlen_pkt-2 */
            *tp++=0x02000000 | ((-2u+aadlen_pkt)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_LENCOR,packetsize-bypass-aadlen_pkt-ivlen-icvlen-1 */
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        *tp++=0x22780000 | ((-1u+packetsize-bypass-aadlen_pkt-ivlen-icvlen)&0x1ffffu)<<0;
        /* REM 2 */
        *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
        if (ivlen > 0u)
        {
            /* RETR NONE,ORIG_IV0,ivlen */
            *tp++=0x40a00000 | ((ivlen)&0x1ffffu)<<0;
        }
        /* REMRES bypass,icvlen,NOUPDCHK          ; Cause the MAC to be removed */
        *tp++=0xa0020000 | ((bypass)&0xffffu)<<0 | ((icvlen)&0x3fu)<<19;
        /* DIRX CRYPTHASH,ORIG_LENCOR,0,LASTHASH */
        *tp++=0x077a0000 | ((0u)&0x1ffffu)<<0;
        /* DIRX CRYPT,ORIG_LENCOR,icvlen+1,LAST,LASTHASHPKT */
        *tp++=0x0d7e0000 | ((1u+icvlen)&0x1ffffu)<<0;
        /* VERIFY icvlen,P,H */
        *tp++=0xd1070000 | ((icvlen)&0x7fu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 12: /* srtp_out */
#if TKB_HAVE_PROTO_SRTP == 1u
        srtp_offset = EVAL_srtp_offset();
        if (packetsize <= bypass+srtp_offset)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SRTP outbound\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        if (srtp_offset > 0u)
        {
            /* DIR  HASH, srtp_offset */
            *tp++=0x03000000 | ((srtp_offset)&0x1ffffu)<<0;
            /* DIR  CRYPTHASH, packetsize - bypass - srtp_offset,LAST */
            *tp++=0x0f000000 | ((packetsize-bypass-srtp_offset)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR  HASH, packetsize - bypass,LAST */
            *tp++=0x0b000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        }
        extseq = EVAL_extseq();
        if (extseq > 0u)
        {
            /* INS  HASH, ORIG_TOKEN, 4, LASTHASH ; SCTCP, index gets appended */
            *tp++=0x23da0000 | ((4u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS  HASHONLY, ORIG_TOKEN, 4, LASTHASH ; SRTP, ROC gets hashed, not appended */
            *tp++=0x22da0000 | ((4u)&0x1ffffu)<<0;
        }
        /* DATA32 srtp_swaproc */
        srtp_swaproc = EVAL_srtp_swaproc();
        *tp++=0x00000000 | ((srtp_swaproc)&0xffffffffu)<<0;
        antireplay = EVAL_antireplay();
        if (antireplay > 0u)
        {
            /* INS OUT,ORIG_SPI,4,LASTHASH */
            *tp++=0x21920000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS OUT, ORIG_HASH, icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 13: /* srtp_in */
#if TKB_HAVE_PROTO_SRTP == 1u
        srtp_offset = EVAL_srtp_offset();
        icvlen = EVAL_icvlen();
        extseq = EVAL_extseq();
        antireplay = EVAL_antireplay();
        if (packetsize <= bypass+srtp_offset+icvlen+extseq+antireplay)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SRTP inbound\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        if (srtp_offset > 0u)
        {
            /* DIR  HASH, srtp_offset */
            *tp++=0x03000000 | ((srtp_offset)&0x1ffffu)<<0;
            /* DIR CRYPTHASH, packetsize - bypass - srtp_offset - icvlen - extseq -antireplay,LAST */
            *tp++=0x0f000000 | ((packetsize-bypass-srtp_offset-icvlen-extseq-antireplay)&0x1ffffu)<<0;
        }
        else
        {
            /* DIR HASH, packetsize - bypass - icvlen - extseq -antireplay,LAST */
            *tp++=0x0b000000 | ((packetsize-bypass-icvlen-extseq-antireplay)&0x1ffffu)<<0;
        }
        if (extseq > 0u)
        {
            /* DIR  HASHONLY, 4, LASTHASH ; SCTCP extraxt from packet. */
            *tp++=0x02020000 | ((4u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS  HASHONLY, ORIG_TOKEN, 4, LASTHASH ; SRTP, ROC gets hashed, not appended */
            *tp++=0x22da0000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 srtp_swaproc */
            srtp_swaproc = EVAL_srtp_swaproc();
            *tp++=0x00000000 | ((srtp_swaproc)&0xffffffffu)<<0;
        }
        if (antireplay > 0u)
        {
            /* RETR NONE,ORIG_SPI,4 */
            *tp++=0x40900000 | ((4u)&0x1ffffu)<<0;
        }
        if (icvlen > 0u)
        {
            /* RETR NONE,ORIG_HASH, icvlen,LASTHASHPKT */
            *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
            if (antireplay > 0u)
            {
                /* VERIFY icvlen,H,SP */
                *tp++=0xd4070000 | ((icvlen)&0x7fu)<<0;
            }
            else
            {
                /* VERIFY icvlen,H */
                *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            }
        }
        else
        {
            /* INS NONE,PAD_ZERO,0,0,LASTHASHPKT */
            *tp++=0x20060000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
            if (antireplay > 0u)
            {
                /* VERIFY 0,SP */
                *tp++=0xd4060000 | ((0u)&0x7fu)<<0;
            }
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 29: /* basic_out_chachapoly */
#if TKB_HAVE_PROTO_BASIC == 1u
#if TKB_HAVE_CRYPTO_CHACHAPOLY == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out ccm\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2bd80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2ad80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt,LAST */
                *tp++=0x0b000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt,LAST */
                *tp++=0x0a000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        else
        {
            /* INS HASHONLY,PAD_ZERO,0,0,LAST */
            *tp++=0x2a000000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        }
        /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass,LAST,LASTHASH */
        *tp++=0x0f020000 | ((packetsize-aadlen_pkt-ivlen-bypass)&0x1ffffu)<<0;
        /* INS OUT, ORIG_HASH, icvlen, LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad crypto\n");
        rc = TKB_BAD_CRYPTO; goto error;
#endif
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 30: /* basic_in_chachapoly */
#if TKB_HAVE_PROTO_BASIC == 1u
#if TKB_HAVE_CRYPTO_CHACHAPOLY == 1u
        aadlen_pkt = EVAL_aadlen_pkt();
        ivlen = EVAL_ivlen();
        if (packetsize < bypass+aadlen_pkt+ivlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic out ccm\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        aadlen_tkn = EVAL_aadlen_tkn();
        if (aadlen_tkn > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* INS HASH,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2bd80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_TOKEN,aadlen_tkn,LAST */
                *tp++=0x2ad80000 | ((aadlen_tkn)&0x1ffffu)<<0;
            }
            aad = EVAL_aad();
            if (aadlen_tkn > 64)
            {
                LOG_CRIT("Field too large\n");
                return TKB_BAD_FIELD_SIZE;
            }
            TokenBuilder_CopyBytes(tp, aad, aadlen_tkn);
            tp += (aadlen_tkn + 3)/4;
        }
        else if (aadlen_pkt > 0u)
        {
            extseq = EVAL_extseq();
            if (extseq > 0u)
            {
                /* DIR HASH,aadlen_pkt,LAST */
                *tp++=0x0b000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
            else
            {
                /* DIR HASHONLY,aadlen_pkt,LAST */
                *tp++=0x0a000000 | ((aadlen_pkt)&0x1ffffu)<<0;
            }
        }
        else
        {
            /* INS HASHONLY,PAD_ZERO,0,0,LAST */
            *tp++=0x2a000000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        }
#if TKB_HAVE_CHACHAPOLY_HW30 == 1u
        /* INS NONE,PAD_ZERO,0,176 */
        *tp++=0x20000000 | ((0u)&0x1u)<<16 | ((176u)&0xffffu)<<0;
#else
        /* INS NONE,PAD_ZERO,0,16 */
        *tp++=0x20000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
#endif
        /* DIR CRYPTHASH,packetsize-aadlen_pkt-ivlen-bypass-icvlen,LAST,LASTHASH */
        icvlen = EVAL_icvlen();
        *tp++=0x0f020000 | ((packetsize-aadlen_pkt-ivlen-bypass-icvlen)&0x1ffffu)<<0;
        /* RETR NONE, ORIG_HASH, antireplay, LASTHASHPKT */
        antireplay = EVAL_antireplay();
        *tp++=0x40e60000 | ((antireplay)&0x1ffffu)<<0;
        /* VERIFY antireplay,H */
        *tp++=0xd0070000 | ((antireplay)&0x7fu)<<0;
#else
        LOG_WARN("TokenBuilder: bad crypto\n");
        rc = TKB_BAD_CRYPTO; goto error;
#endif
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 31: /* tls13_gcm_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        if (packetsize < bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS outbound GCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* INS HASH,PAD_CONST,0x17,1    ; Type field */
        *tp++=0x23100000 | ((23u)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASH,ORIG_SPI,2          ; For TLS1.3 hash fixed type/version field. */
        *tp++=0x23900000 | ((2u)&0x1ffffu)<<0;
        /* INS HASH,ORIG_TOKEN,2,LAST */
        *tp++=0x2bd80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swap_fraglen_tls13    ; Fragment length to output and hash. */
        swap_fraglen_tls13 = EVAL_swap_fraglen_tls13();
        *tp++=0x00000000 | ((swap_fraglen_tls13)&0xffffffffu)<<0;
        /* REMRES bypass + 5, 16 */
        *tp++=0xa0000000 | ((5u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR CRYPTHASH, packetsize-bypass */
        *tp++=0x07000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        count = EVAL_count();
        if (count == 0u)
        {
            /* INS CRYPTHASH, PAD_CONST, nextheader, 1, LAST, LASTHASH */
            nextheader = EVAL_nextheader();
            *tp++=0x2f120000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        }
        else
        {
            /* INS CRYPTHASH, PAD_CONST, nextheader, 1 */
            nextheader = EVAL_nextheader();
            *tp++=0x27100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
            /* INS CRYPTHASH, PAD_ZERO, 0, count, LAST, LASTHASH */
            *tp++=0x2f020000 | ((0u)&0x1u)<<16 | ((count)&0xffffu)<<0;
        }
        /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX ORIG_SEQNUM,seq_offset,2 */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 32: /* tls13_gcm_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        icvlen = EVAL_icvlen();
        if (packetsize < 5u+bypass+icvlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS inbound GCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* DIR HASHONLY,5,LAST       ; Hash type and version number and length */
        *tp++=0x0a000000 | ((5u)&0x1ffffu)<<0;
        /* REMRES bypass, 16 */
        *tp++=0xa0000000 | ((bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR CRYPTHASH, packetsize-bypass-icvlen-5,LAST,LASTHASH */
        *tp++=0x0f020000 | ((-5u+packetsize-bypass-icvlen)&0x1ffffu)<<0;
        /* RETR NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY icvlen,H */
        *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
        /* CTX ORIG_SEQNUM,seq_offset,2,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 33: /* tls13_chachapoly_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        if (packetsize < bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS outbound ChaChaPoly\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* INS HASH,PAD_CONST,0x17,1    ; Type field */
        *tp++=0x23100000 | ((23u)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASH,ORIG_SPI,2          ; For TLS1.3 hash fixed type/version field. */
        *tp++=0x23900000 | ((2u)&0x1ffffu)<<0;
        /* INS HASH,ORIG_TOKEN,2,LAST */
        *tp++=0x2bd80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swap_fraglen_tls13    ; Fragment length to output and hash. */
        swap_fraglen_tls13 = EVAL_swap_fraglen_tls13();
        *tp++=0x00000000 | ((swap_fraglen_tls13)&0xffffffffu)<<0;
        /* DIR CRYPTHASH, packetsize-bypass */
        *tp++=0x07000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        count = EVAL_count();
        if (count == 0u)
        {
            /* INS CRYPTHASH, PAD_CONST, nextheader, 1, LAST, LASTHASH */
            nextheader = EVAL_nextheader();
            *tp++=0x2f120000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        }
        else
        {
            /* INS CRYPTHASH, PAD_CONST, nextheader, 1 */
            nextheader = EVAL_nextheader();
            *tp++=0x27100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
            /* INS CRYPTHASH, PAD_ZERO, 0, count, LAST, LASTHASH */
            *tp++=0x2f020000 | ((0u)&0x1u)<<16 | ((count)&0xffffu)<<0;
        }
        /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX ORIG_SEQNUM,seq_offset,2 */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 34: /* tls13_chachapoly_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        icvlen = EVAL_icvlen();
        if (packetsize < 5u+bypass+icvlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS inbound ChaChaPoly\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* DIR HASHONLY,5,LAST       ; Hash type and version number and length */
        *tp++=0x0a000000 | ((5u)&0x1ffffu)<<0;
        /* INS NONE, PAD_ZERO, 0, 16 */
        *tp++=0x20000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR CRYPTHASH, packetsize-bypass-icvlen-5,LAST,LASTHASH */
        *tp++=0x0f020000 | ((-5u+packetsize-bypass-icvlen)&0x1ffffu)<<0;
        /* RETR NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY icvlen,H */
        *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
        /* CTX ORIG_SEQNUM,seq_offset,2,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 35: /* esp_out_chachapoly */
#if TKB_HAVE_PROTO_IPSEC == 1u
        if (packetsize <= bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP outbound ChaChaPoly\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* INS      HASH,ORIG_SPI,8,LAST */
            *tp++=0x2b900000 | ((8u)&0x1ffffu)<<0;
        }
        else
        {
            /* INS      HASH,ORIG_SPI,4 */
            *tp++=0x23900000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY, ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASH,ORIG_SEQNUM_RES, 4, LAST */
            *tp++=0x2b980000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS      OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        /* DIR      CRYPTHASH, packetsize-bypass-hdrlen */
        *tp++=0x07000000 | ((packetsize-bypass-hdrlen)&0x1ffffu)<<0;
        /* INS      CRYPTHASH,PAD_IPSEC,nextheader,pad_bytes,LAST,LASTHASH */
        nextheader = EVAL_nextheader();
        pad_bytes = EVAL_pad_bytes();
        *tp++=0x2f220000 | ((nextheader)&0xffu)<<9 | ((pad_bytes)&0x1ffu)<<0;
        /* INS      OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX      ORIG_SEQNUM,seq_offset,1+extseq */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 36: /* esp_in_chachapoly */
#if TKB_HAVE_PROTO_IPSEC == 1u
        ivlen = EVAL_ivlen();
        icvlen = EVAL_icvlen();
        pad_blocksize = EVAL_pad_blocksize();
        if (packetsize < 8u+ivlen+icvlen+pad_blocksize+bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for ESP inbound ChaChaPoly\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        pad_remainder = EVAL_pad_remainder();
        if (pad_remainder != 0u)
        {
            LOG_WARN("TokenBuilder: bad packet, pad alignment ESP inbound ChaChaPoly\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        extseq = EVAL_extseq();
        if (extseq != 1u)
        {
            /* RETR     HASHONLY,ORIG_SPI,8,LAST */
            *tp++=0x4a900000 | ((8u)&0x1ffffu)<<0;
            /* RETR     NONE,ORIG_IV1,ivlen */
            *tp++=0x40a80000 | ((ivlen)&0x1ffffu)<<0;
#if TKB_HAVE_ECN_FIXUP == 1u
            /* DATA32 ecn_fixup_instr */
            ecn_fixup_instr = EVAL_ecn_fixup_instr();
            *tp++=0x00000000 | ((ecn_fixup_instr)&0xffffffffu)<<0;
#endif
            /* INS      NONE, PAD_ZERO, 0, 16 */
            *tp++=0x20000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        }
        else
        {
            /* RETR     HASHONLY,ORIG_SPI,4 */
            *tp++=0x42900000 | ((4u)&0x1ffffu)<<0;
            /* RETR     NONE,ORIG_SEQNUM_RES,4 */
            *tp++=0x40980000 | ((4u)&0x1ffffu)<<0;
            /* RETR     NONE,ORIG_IV1,ivlen */
            *tp++=0x40a80000 | ((ivlen)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_EXTSEQNUM_RES2, 4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS      HASHONLY,ORIG_SEQNUM_RES,4,LAST */
            *tp++=0x2a980000 | ((4u)&0x1ffffu)<<0;
#if TKB_HAVE_ECN_FIXUP == 1u
            /* DATA32 ecn_fixup_instr */
            ecn_fixup_instr = EVAL_ecn_fixup_instr();
            *tp++=0x00000000 | ((ecn_fixup_instr)&0xffffffffu)<<0;
#endif
#if TKB_HAVE_CHACHAPOLY_HW30 == 1u
            /* INS      NONE, PAD_ZERO, 0, 160 */
            *tp++=0x20000000 | ((0u)&0x1u)<<16 | ((160u)&0xffffu)<<0;
#else
            /* INS      NONE, PAD_ZERO, 0, 16 */
            *tp++=0x20000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
#endif
        }
        /* DIR      CRYPTHASH,packetsize - ivlen - 8 - icvlen - bypass - hdrlen,LAST,LASTHASH */
        *tp++=0x0f020000 | ((-8u+packetsize-ivlen-icvlen-bypass-hdrlen)&0x1ffffu)<<0;
        /* RETR     NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 39: /* ssltls_ccm_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        if (packetsize < bypass+hdrlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS outbound CCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        if (hdrlen > 0u)
        {
            /* DIR OUT,hdrlen */
            *tp++=0x01000000 | ((hdrlen)&0x1ffffu)<<0;
        }
        capwap_out = EVAL_capwap_out();
        if (capwap_out != 0u)
        {
            /* INS OUT,ORIG_TOKEN,4 */
            *tp++=0x21d80000 | ((4u)&0x1ffffu)<<0;
            /* DATA32 0x0000001  ; Insert DTLS/CAPWAP header. */
            *tp++=0x00000000 | ((1u)&0xffffffffu)<<0;
        }
        /* INS HASHONLY,PAD_CONST,salt,1 ; Form b0 block, flag byte */
        salt = EVAL_salt();
        *tp++=0x22100000 | ((salt)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASHONLY,ORIG_IV0,4 */
        *tp++=0x22a00000 | ((4u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_EXTSEQNUM,4 */
        *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_SEQNUM,4 */
        *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_TOKEN,5 */
        *tp++=0x22d80000 | ((5u)&0x1ffffu)<<0;
        /* DATA32 swaplen3                 ; 3-byte length in b0 block. */
        swaplen3 = EVAL_swaplen3();
        *tp++=0x00000000 | ((swaplen3)&0xffffffffu)<<0;
        /* DATA32 0x0d                     ; and swapped 2-byte AAD length just after */
        *tp++=0x00000000 | ((13u)&0xffffffffu)<<0;
        /* INS HASHONLY,ORIG_EXTSEQNUM,4 */
        *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_SEQNUM,4 */
        *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
        /* INS HASH,PAD_CONST,nextheader,1 ; Type field */
        nextheader = EVAL_nextheader();
        *tp++=0x23100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASH,ORIG_SPI,2          ; For TLS/DTLS, hash version field. */
        *tp++=0x23900000 | ((2u)&0x1ffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq != 0u)
        {
            /* INS OUT,ORIG_EXTSEQNUM,4 ; Output sequence number for DTLS */
            *tp++=0x21580000 | ((4u)&0x1ffffu)<<0;
            /* INS OUT,ORIG_SEQNUM,4 */
            *tp++=0x21500000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,ORIG_TOKEN,2 */
        *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swaplen                   ; Payload length to hash. */
        swaplen = EVAL_swaplen();
        *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        /* INS HASHONLY,PAD_ZERO,0,1        ; Pad AAD to 16 bytes. */
        *tp++=0x22000000 | ((0u)&0x1u)<<16 | ((1u)&0xffffu)<<0;
        /* INS OUT,ORIG_TOKEN,2 */
        *tp++=0x21d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swap_fraglen              ; Fragment length to output. */
        swap_fraglen = EVAL_swap_fraglen();
        *tp++=0x00000000 | ((swap_fraglen)&0xffffffffu)<<0;
        /* INS OUT,ORIG_IV1,ivlen */
        ivlen = EVAL_ivlen();
        *tp++=0x21a80000 | ((ivlen)&0x1ffffu)<<0;
        if (extseq != 0u)
        {
            /* REMRES bypass + hdrlen + capwap_out + 5 + 8 + 8, 16 */
            *tp++=0xa0000000 | ((21u+bypass+hdrlen+capwap_out)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        else
        {
            /* REMRES bypass + hdrlen + 5 + 8, 16 */
            *tp++=0xa0000000 | ((13u+bypass+hdrlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        }
        /* INS CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        if (packetsize != bypass+hdrlen)
        {
            /* DIR CRYPTHASH, packetsize-bypass-hdrlen,LAST */
            *tp++=0x0f000000 | ((packetsize-bypass-hdrlen)&0x1ffffu)<<0;
        }
        else
        {
            /* INS CRYPTHASH, PAD_ZERO, 0, 0,LAST */
            *tp++=0x2f000000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        }
        /* INS HASHONLY,PAD_ZERO,0,hashpad,LASTHASH */
        hashpad = EVAL_hashpad();
        *tp++=0x22020000 | ((0u)&0x1u)<<16 | ((hashpad)&0xffffu)<<0;
        /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX ORIG_SEQNUM,seq_offset,2 */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 40: /* ssltls_ccm_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        paylen = EVAL_paylen();
        if (paylen == 4294967295u)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS inbound CCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        if (hdrlen > 0u)
        {
            /* DIR OUT,hdrlen */
            *tp++=0x01000000 | ((hdrlen)&0x1ffffu)<<0;
        }
        capwap_in = EVAL_capwap_in();
        if (capwap_in != 0u)
        {
            /* REM 4  ; Remove DTLS/CAPWAP header. */
            *tp++=0x40d80000 | ((4u)&0x1ffffu)<<0;
        }
        /* INS HASHONLY,PAD_CONST,salt,1 ; Form b0 block, flag byte */
        salt = EVAL_salt();
        *tp++=0x22100000 | ((salt)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASHONLY,ORIG_IV0,4 */
        *tp++=0x22a00000 | ((4u)&0x1ffffu)<<0;
        ohdrlen = EVAL_ohdrlen();
        if (ohdrlen > hdrlen)
        {
            /* RETR OUT,ORIG_SPI,3    ; Extract Type and Version. */
            *tp++=0x41900000 | ((3u)&0x1ffffu)<<0;
            /* RETR NONE,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
            *tp++=0x40480000 | ((4u)&0x1ffffu)<<0;
            /* RETR NONE,ORIG_SEQNUM_RES2,4 */
            *tp++=0x40400000 | ((4u)&0x1ffffu)<<0;
            /* REM 2                    ; Remove fragment length. */
            *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_IV1,ivlen */
            ivlen = EVAL_ivlen();
            *tp++=0x42a80000 | ((ivlen)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_TOKEN,5 */
            *tp++=0x22d80000 | ((5u)&0x1ffffu)<<0;
            /* DATA32 swaplen3                 ; 3-byte length in b0 block. */
            swaplen3 = EVAL_swaplen3();
            *tp++=0x00000000 | ((swaplen3)&0xffffffffu)<<0;
            /* DATA32 0x0d                     ; and swapped 2-byte AAD length just after */
            *tp++=0x00000000 | ((13u)&0xffffffffu)<<0;
            /* INS HASHONLY, ORIG_EXTSEQNUM_RES2,4 */
            *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
            /* INS HASHONLY, ORIG_SEQNUM_RES2,4 */
            *tp++=0x22400000 | ((4u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
            *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
            /* INS HASH,ORIG_TOKEN,2 */
            *tp++=0x23d80000 | ((2u)&0x1ffffu)<<0;
            /* DATA32 swaplen */
            swaplen = EVAL_swaplen();
            *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
            if (ohdrlen-hdrlen > 5u)
            {
                /* INS OUT,PAD_ZERO,0,ohdrlen-hdrlen-5 */
                *tp++=0x21000000 | ((0u)&0x1u)<<16 | ((-5u+ohdrlen-hdrlen)&0xffffu)<<0;
            }
        }
        else
        {
            /* RETR NONE,ORIG_SPI,3    ; Extract Type and Version. */
            *tp++=0x40900000 | ((3u)&0x1ffffu)<<0;
            extseq = EVAL_extseq();
            if (extseq != 0u)
            {
                /* RETR NONE,ORIG_EXTSEQNUM_RES2,4 ; Extract seq numbers from packet. */
                *tp++=0x40480000 | ((4u)&0x1ffffu)<<0;
                /* RETR NONE,ORIG_SEQNUM_RES2,4 */
                *tp++=0x40400000 | ((4u)&0x1ffffu)<<0;
            }
            /* REM 2                    ; Remove fragment length. */
            *tp++=0x40d80000 | ((2u)&0x1ffffu)<<0;
            /* RETR HASHONLY,ORIG_IV1,ivlen */
            ivlen = EVAL_ivlen();
            *tp++=0x42a80000 | ((ivlen)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_TOKEN,5 */
            *tp++=0x22d80000 | ((5u)&0x1ffffu)<<0;
            /* DATA32 swaplen3                 ; 3-byte length in b0 block. */
            swaplen3 = EVAL_swaplen3();
            *tp++=0x00000000 | ((swaplen3)&0xffffffffu)<<0;
            /* DATA32 0x0d                     ; and swapped 2-byte AAD length just after */
            *tp++=0x00000000 | ((13u)&0xffffffffu)<<0;
            if (extseq != 0u)
            {
                /* INS HASHONLY,ORIG_EXTSEQNUM_RES2,4  ; Extract from SA. */
                *tp++=0x22480000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SEQNUM_RES2,4 */
                *tp++=0x22400000 | ((4u)&0x1ffffu)<<0;
            }
            else
            {
                /* INS HASHONLY,ORIG_EXTSEQNUM,4  ; Extract from SA. */
                *tp++=0x22580000 | ((4u)&0x1ffffu)<<0;
                /* INS HASHONLY,ORIG_SEQNUM,4 */
                *tp++=0x22500000 | ((4u)&0x1ffffu)<<0;
            }
            /* INS HASHONLY,ORIG_SPI_RES,3  ; Hash type and version. */
            *tp++=0x22c00000 | ((3u)&0x1ffffu)<<0;
            /* INS HASHONLY,ORIG_TOKEN,2 */
            *tp++=0x22d80000 | ((2u)&0x1ffffu)<<0;
            /* DATA32 swaplen */
            swaplen = EVAL_swaplen();
            *tp++=0x00000000 | ((swaplen)&0xffffffffu)<<0;
        }
        /* INS HASHONLY,PAD_ZERO,0,1      ; Pad AAD to 16 bytes. */
        *tp++=0x22000000 | ((0u)&0x1u)<<16 | ((1u)&0xffffu)<<0;
        /* REMRES bypass+ohdrlen, 16 */
        *tp++=0xa0000000 | ((bypass+ohdrlen)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR CRYPTHASH, paylen,LAST */
        *tp++=0x0f000000 | ((paylen)&0x1ffffu)<<0;
        /* INS HASHONLY,PAD_ZERO,0,hashpad,LASTHASH */
        hashpad = EVAL_hashpad();
        *tp++=0x22020000 | ((0u)&0x1u)<<16 | ((hashpad)&0xffffu)<<0;
        /* RETR NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        extseq = EVAL_extseq();
        if (extseq == 0u)
        {
            /* VERIFY icvlen,H */
            *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,2,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
        }
        else if (extseq == 1u)
        {
            /* VERIFY icvlen,H */
            *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
        }
        else
        {
            /* VERIFY icvlen,S,H */
            *tp++=0xd8070000 | ((icvlen)&0x7fu)<<0;
            /* CTX ORIG_SEQNUM,seq_offset,1+extseq,P */
            seq_offset = EVAL_seq_offset();
            *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((1u+extseq)&0xfu)<<24;
        }
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 41: /* tls13_ccm_out */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        if (packetsize < bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS outbound GCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* INS HASHONLY,PAD_CONST,salt,1 ; Form b0 block, flag byte */
        salt = EVAL_salt();
        *tp++=0x22100000 | ((salt)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASHONLY,ORIG_IV0,12 */
        *tp++=0x22a00000 | ((12u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_TOKEN,5 */
        *tp++=0x22d80000 | ((5u)&0x1ffffu)<<0;
        /* DATA32 swaplen3_tls13_out       ; 3-byte length in b0 block. */
        swaplen3_tls13_out = EVAL_swaplen3_tls13_out();
        *tp++=0x00000000 | ((swaplen3_tls13_out)&0xffffffffu)<<0;
        /* DATA32 0x05                     ; and swapped 2-byte AAD length just after */
        *tp++=0x00000000 | ((5u)&0xffffffffu)<<0;
        /* INS HASH,PAD_CONST,0x17,1    ; Type field */
        *tp++=0x23100000 | ((23u)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASH,ORIG_SPI,2          ; For TLS1.3 hash fixed type/version field. */
        *tp++=0x23900000 | ((2u)&0x1ffffu)<<0;
        /* INS HASH,ORIG_TOKEN,2 */
        *tp++=0x23d80000 | ((2u)&0x1ffffu)<<0;
        /* DATA32 swap_fraglen_tls13     ; Fragment length to output and hash. */
        swap_fraglen_tls13 = EVAL_swap_fraglen_tls13();
        *tp++=0x00000000 | ((swap_fraglen_tls13)&0xffffffffu)<<0;
        /* INS HASHONLY,PAD_ZERO,0,9     ; Pad AAD block */
        *tp++=0x22000000 | ((0u)&0x1u)<<16 | ((9u)&0xffffu)<<0;
        /* REMRES bypass + 5, 16 */
        *tp++=0xa0000000 | ((5u+bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR CRYPTHASH, packetsize-bypass */
        *tp++=0x07000000 | ((packetsize-bypass)&0x1ffffu)<<0;
        count = EVAL_count();
        if (count == 0u)
        {
            /* INS CRYPTHASH, PAD_CONST, nextheader, 1,LAST */
            nextheader = EVAL_nextheader();
            *tp++=0x2f100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        }
        else
        {
            /* INS CRYPTHASH, PAD_CONST, nextheader, 1 */
            nextheader = EVAL_nextheader();
            *tp++=0x27100000 | ((nextheader)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
            /* INS CRYPTHASH, PAD_ZERO, 0, count, LAST */
            *tp++=0x2f000000 | ((0u)&0x1u)<<16 | ((count)&0xffffu)<<0;
        }
        /* INS HASHONLY,PAD_ZERO, 0, hashpad_tls13_out, LASTHASH */
        hashpad_tls13_out = EVAL_hashpad_tls13_out();
        *tp++=0x22020000 | ((0u)&0x1u)<<16 | ((hashpad_tls13_out)&0xffffu)<<0;
        /* INS OUT,ORIG_HASH,icvlen,LASTHASHPKT */
        icvlen = EVAL_icvlen();
        *tp++=0x21e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY   0  ; Causes any sequence number rollover error to fail the packet. */
        *tp++=0xd0060000 | ((0u)&0x7fu)<<0;
        /* CTX ORIG_SEQNUM,seq_offset,2 */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0560800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 42: /* tls13_ccm_in */
#if TKB_HAVE_PROTO_SSLTLS == 1u
        icvlen = EVAL_icvlen();
        if (packetsize < 5u+bypass+icvlen)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for SSLTLS inbound GCM\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* INS HASHONLY,PAD_CONST,salt,1 ; Form b0 block, flag byte */
        salt = EVAL_salt();
        *tp++=0x22100000 | ((salt)&0xffu)<<9 | ((1u)&0x1ffu)<<0;
        /* INS HASHONLY,ORIG_IV0,12 */
        *tp++=0x22a00000 | ((12u)&0x1ffffu)<<0;
        /* INS HASHONLY,ORIG_TOKEN,5 */
        *tp++=0x22d80000 | ((5u)&0x1ffffu)<<0;
        /* DATA32 swaplen3_tls13_in        ; 3-byte length in b0 block. */
        swaplen3_tls13_in = EVAL_swaplen3_tls13_in();
        *tp++=0x00000000 | ((swaplen3_tls13_in)&0xffffffffu)<<0;
        /* DATA32 0x05                     ; and swapped 2-byte AAD length just after */
        *tp++=0x00000000 | ((5u)&0xffffffffu)<<0;
        /* DIR HASHONLY,5                  ; Hash type and version number and length */
        *tp++=0x02000000 | ((5u)&0x1ffffu)<<0;
        /* INS HASHONLY,PAD_ZERO,0,9       ; Pad AAD block */
        *tp++=0x22000000 | ((0u)&0x1u)<<16 | ((9u)&0xffffu)<<0;
        /* REMRES bypass, 16 */
        *tp++=0xa0000000 | ((bypass)&0xffffu)<<0 | ((16u)&0x3fu)<<19;
        /* INS CRYPT, PAD_ZERO, 0, 16 */
        *tp++=0x25000000 | ((0u)&0x1u)<<16 | ((16u)&0xffffu)<<0;
        /* DIR CRYPTHASH, packetsize-bypass-icvlen-5,LAST */
        *tp++=0x0f000000 | ((-5u+packetsize-bypass-icvlen)&0x1ffffu)<<0;
        /* INS HASHONLY,PAD_ZERO, 0, hashpad_tls13_in, LASTHASH */
        hashpad_tls13_in = EVAL_hashpad_tls13_in();
        *tp++=0x22020000 | ((0u)&0x1u)<<16 | ((hashpad_tls13_in)&0xffffu)<<0;
        /* RETR NONE,ORIG_HASH,icvlen,LASTHASHPKT */
        *tp++=0x40e60000 | ((icvlen)&0x1ffffu)<<0;
        /* VERIFY icvlen,H */
        *tp++=0xd0070000 | ((icvlen)&0x7fu)<<0;
        /* CTX ORIG_SEQNUM,seq_offset,2,P */
        seq_offset = EVAL_seq_offset();
        *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 43: /* basic_hmac_precompute */
#if TKB_HAVE_PROTO_BASIC == 1u
        if (packetsize < bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic hash precompute\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* DIR HASHONLY,packetsize-bypass,LASTHASH */
        *tp++=0x02020000 | ((packetsize-bypass)&0x1ffffu)<<0;
        /* INS OUT, ORIG_HASH,hstatelen_bytes */
        hstatelen_bytes = EVAL_hstatelen_bytes();
        *tp++=0x21e00000 | ((hstatelen_bytes)&0x1ffffu)<<0;
        /* INS NONE,PAD_ZERO, 0, 0 */
        *tp++=0x20000000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        /* INS OUT,ORIG_HASH,hstatelen_bytes,LASTHASHPKT */
        *tp++=0x21e60000 | ((hstatelen_bytes)&0x1ffffu)<<0;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 44: /* basic_hmac_ctxprepare */
#if TKB_HAVE_PROTO_BASIC == 1u
        if (packetsize < bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic hash precompute\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* DIR HASHONLY,packetsize-bypass,LASTHASH */
        *tp++=0x02020000 | ((packetsize-bypass)&0x1ffffu)<<0;
        /* INS NONE, ORIG_HASH,hstatelen_bytes */
        hstatelen_bytes = EVAL_hstatelen_bytes();
        *tp++=0x20e00000 | ((hstatelen_bytes)&0x1ffffu)<<0;
        /* INS NONE,PAD_ZERO, 0, 0 */
        *tp++=0x20000000 | ((0u)&0x1u)<<16 | ((0u)&0xffffu)<<0;
        /* INS NONE,ORIG_HASH,hstatelen_bytes,LASTHASHPKT */
        *tp++=0x20e60000 | ((hstatelen_bytes)&0x1ffffu)<<0;
        /* CTX ORIG_HASH_INNER,digest_offset,hstatelen,P,F */
        digest_offset = EVAL_digest_offset();
        hstatelen = EVAL_hstatelen();
        *tp++=0xe0ee3800 | ((digest_offset)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
        /* CTX ORIG_HASH,digest_offset+hstatelen,hstatelen,P,F */
        *tp++=0xe0e63800 | ((digest_offset+hstatelen)&0xffu)<<0 | ((hstatelen)&0xfu)<<24;
#else
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
#endif
        break;
    case 45: /* basic_bypass */
        if (packetsize < bypass)
        {
            LOG_WARN("TokenBuilder: bad packet, too short for basic bypass\n");
            rc = TKB_BAD_PACKET; goto error;
        }
        /* DIR OUT,packetsize-bypass,LASTHASHPKT */
        *tp++=0x01060000 | ((packetsize-bypass)&0x1ffffu)<<0;
        break;
    default:
        LOG_WARN("TokenBuilder: bad protocol\n");
        rc = TKB_BAD_PROTOCOL; goto error;
    }
#if TKB_HAVE_PROTO_IPSEC == 1u
#if TKB_HAVE_EXTENDED_IPSEC == 1u
    hproto = EVAL_hproto();
    switch(hproto)
    {
    case 6: /* ipv4_in_transp */
    case 26: /* ipv4_in_transp_natt */
        /* INSRES 2+bypass,7,L,NH,CS,LASTINS */
        *tp++=0xae050000 | ((2u+bypass)&0xffffu)<<0 | ((7u)&0x3fu)<<19;
        break;
    case 12: /* ipv6_in_transp */
    case 32: /* ipv6_in_transp_natt */
        /* INSRES 4+bypass,40,L,NOUPDCHK */
        *tp++=0xa8030000 | ((4u+bypass)&0xffffu)<<0 | ((40u)&0x3fu)<<19;
        /* INSRES bypass+prev_nhoffset,0,NH,NOUPDCHK,LASTINS */
        prev_nhoffset = EVAL_prev_nhoffset();
        *tp++=0xa4070000 | ((bypass+prev_nhoffset)&0xffffu)<<0 | ((0u)&0x3fu)<<19;
        break;
    }
#endif
    switch(proto)
    {
    case 1: /* esp_in */
    case 3: /* esp_in_ccm */
    case 5: /* esp_in_gcm */
    case 7: /* esp_in_gmac */
    case 36: /* esp_in_chachapoly */
        icvlen = EVAL_icvlen();
        if (icvlen > 0u)
        {
            antireplay = EVAL_antireplay();
            if (antireplay > 12u)
            {
                /* VERIFY   icvlen,S,SP,P,H */
                *tp++=0xdd070000 | ((icvlen)&0x7fu)<<0;
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* CTX     ORIG_SEQNUM,seq_offset,0,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((0u)&0xfu)<<24;
                }
                else
                {
                    /* CTX     ORIG_SEQNUM_INBOUND,seq_offset,0,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe02e1800 | ((seq_offset)&0xffu)<<0 | ((0u)&0xfu)<<24;
                }
            }
            else if (antireplay != 0u)
            {
                /* VERIFY   icvlen,S,SP,P,H */
                *tp++=0xdd070000 | ((icvlen)&0x7fu)<<0;
                extseq = EVAL_extseq();
                if (extseq > 0u)
                {
                    /* CTX     ORIG_SEQNUM,seq_offset,2+antireplay,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe0561800 | ((seq_offset)&0xffu)<<0 | ((2u+antireplay)&0xfu)<<24;
                }
                else
                {
                    /* CTX     ORIG_SEQNUM_INBOUND,seq_offset,1+antireplay,P */
                    seq_offset = EVAL_seq_offset();
                    *tp++=0xe02e1800 | ((seq_offset)&0xffu)<<0 | ((1u+antireplay)&0xfu)<<24;
                }
            }
            else
            {
                /* VERIFY   icvlen,SP,P,H */
                *tp++=0xd5070000 | ((icvlen)&0x7fu)<<0;
            }
        }
        else
        {
            /* VERIFY   0,SP,P */
            *tp++=0xd5060000 | ((0u)&0x7fu)<<0;
        }
        break;
    }
#endif


    Switch_Proto(TokenContext_Internal_p);

error:
    if (rc != TKB_STATUS_OK)
    {
        tp = (uint32_t *)Token_p + TKB_TOKEN_HEADER_WORD_COUNT;
        /* Include CCW0 and CCW1 in token. */
        *tp++ = 0;
        *tp++ = 0;
        /* DIR OUT,PacketByteCount,LASTHASHPKT pass packet unchanged */
        *tp++ = 0x01060000 | (PacketByteCount & 0x1ffff);
        *TokenHeaderWord_p = TKB_HEADER_DEFAULT | TKB_HEADER_C | (PacketByteCount & 0x1ffff);
    }
    *TokenWord32Count_p = tp - (uint32_t*)Token_p;
    return rc;
}

/* end of file token_builder_core.c */
